var documenterSearchIndex = {"docs":
[{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"rigidbody.html#Rigid-Bodies-1","page":"Rigid Bodies","title":"Rigid Bodies","text":"","category":"section"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"Many aerospace systems, such as airplanes, drones, spacecraft, or even underwater vehicles such as submarines, are conveniently described as a single rigid body described by its 3D position, orientation, and linear and angular velocities. Since these systems are relatively common, RobotDynamics provides the RigidBody model type that is a special case of the LieGroupModel. In fact, a RigidBody is simply a LieGroupModel with a LieState of LieState{R,(3,6)}, since we define the state vector to be [r,q,v,ω] where r is the 3D position, q is the orientation of the body in the world frame (q rotates vectors in the body frame to the world frame), v is the 3D linear velocity in either the world, or body frame, and ω is the 3D angular velocity in the body frame.","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"RigidBody","category":"page"},{"location":"rigidbody.html#RobotDynamics.RigidBody","page":"Rigid Bodies","title":"RobotDynamics.RigidBody","text":"RigidBody{R<:Rotation} <: LieGroupModel\n\nAbstraction of a dynamical system with free-body dynamics, with a 12 or 13-dimensional state vector: [p; q; v; ω] where p is the 3D position, q is the 3 or 4-dimension attitude representation, v is the 3D linear velocity, and ω is the 3D angular velocity.\n\nInterface\n\nAny single-body system can leverage the RigidBody type by inheriting from it and defining the following interface:\n\nforces(::MyRigidBody, x, u)  # return the forces in the world frame\nmoments(::MyRigidBody, x, u) # return the moments in the body frame\ninertia(::MyRigidBody, x, u) # return the 3x3 inertia matrix\nmass(::MyRigidBody, x, u)  # return the mass as a real scalar\n\nInstead of defining forces and moments you can define the higher-level wrenches function \twrenches(model::MyRigidbody, z::AbstractKnotPoint) \twrenches(model::MyRigidbody, x, u)\n\nRotation Parameterization\n\nA RigidBody model must specify the rotational representation being used. Any Rotations.Rotation{3} can be used, but we suggest one of the following:\n\nUnitQuaternion\nMRP\nRodriguesParam\n\n\n\n\n\n","category":"type"},{"location":"rigidbody.html#Defining-a-New-Rigid-Body-Model-1","page":"Rigid Bodies","title":"Defining a New Rigid Body Model","text":"","category":"section"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"Let's define the simplest rigid body: a satellite moving freely in 3D space with full 6 DOF control.","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"We start by defining a new struct that inherits from RigidBody{R} and specifying the number of controls. Note that state_dim should NOT be specified since it is calculated automatically and depends on the number of parameters in the rotation representation R.","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"using RobotDynamics\nusing Rotations\nusing StaticArrays, LinearAlgebra\n\n# Define the model struct to inherit from `RigidBody{R}`\nstruct Satellite{R,T} <: RigidBody{R}\n    mass::T\n    J::Diagonal{T,SVector{3,T}}\nend\nRobotDynamics.control_dim(::Satellite) = 6","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"We now define a few \"getter\" methods that are required to evaluation the dynamics.","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"RobotDynamics.mass(model::Satellite) = model.mass\nRobotDynamics.inertia(model::Satellite) = model.J","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"With those methods specified, all that is left to do is to define the forces and moments acting on the center of mass of the rigid body. We assume all forces are specified in the world frame and moments are specified in the body frame.","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"# Define the 3D forces at the center of mass, in the world frame\nfunction RobotDynamics.forces(model::Satellite, x::StaticVector, u::StaticVector)\n    q = orientation(model, x)\n    F = @SVector [u[1], u[2], u[3]]\n    q*F  # world frame\nend\n\n# Define the 3D moments at the center of mass, in the body frame\nfunction RobotDynamics.moments(model::Satellite, x::StaticVector, u::StaticVector)\n    return @SVector [u[4], u[5], u[6]]  # body frame\nend","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"Alternatively, we could define the method wrenches directly:","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"function RobotDynamics.wrenches(model::Satellite, z::AbstractKnotPoint)\n    x = state(z)\n    u = control(z)\n    q = orientation(model, x)\n    F = q * (@SVector [u[1], u[2], u[3]])\n    M = @SVector [u[4], u[5], u[6]]  # body frame\n    return SA[F[1], F[2], F[3], M[1], M[2], M[3]]\nend","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"which can take either an AbstractKnotPoint or x and u directly. By passing in a knot point, we have access to the time t, allowing for time-varying wrenches.","category":"page"},{"location":"rigidbody.html#Useful-Methods-1","page":"Rigid Bodies","title":"Useful Methods","text":"","category":"section"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"The following methods are provided to make it easier to define methods for rigid bodies.","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"To extract the individual components of the state use the following exported methods:","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"position(model::RigidBody, x)\norientation(model::RigidBody, x, [renorm=false])\nlinear_velocity(model::RigidBody, x)\nangular_velocity(model::RigidBody, x)","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"Alternatively, you can use the following methods:","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"parse_state\ngen_inds","category":"page"},{"location":"rigidbody.html#RobotDynamics.parse_state","page":"Rigid Bodies","title":"RobotDynamics.parse_state","text":"parse_state(model::RigidBody{R}, x, renorm=false)\n\nReturn the position, orientation, linear velocity, and angular velocity as separate vectors. The orientation will be of type R. If renorm=true and R <: UnitQuaternion the quaternion will be renormalized.\n\n\n\n\n\n","category":"function"},{"location":"rigidbody.html#RobotDynamics.gen_inds","page":"Rigid Bodies","title":"RobotDynamics.gen_inds","text":"gen_inds(model::RigidBody)\n\nGenerate a NamedTuple containing the indices of the position (r), orientation (q), linear velocity (v), and angular velocity (ω) from the state vector for model.\n\n\n\n\n\n","category":"function"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"Another approach is to use the RBState, which is useful to describe a generic state for a rigid body, regardless of the rotation representation:","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"RBState","category":"page"},{"location":"rigidbody.html#RobotDynamics.RBState","page":"Rigid Bodies","title":"RobotDynamics.RBState","text":"RBState{T} <: StaticVector{13,T}\n\nRepresents the state of a rigid body in 3D space, consisting of position, orientation, linear     velocity and angular velocity, respresented as a vector stacked in that order, with     the rotation represented as the 4 elements of a unit quaternion.\n\nImplements the StaticArrays interface so can be treated as an SVector with additional     methods.\n\nConstructors\n\nRBState{T}(r, q, v, ω)\nRBState{T}(x)\nRBState(r, q, v, ω)\nRBState(x)\n\nwhere r, v, and ω are three-dimensional vectors, q is either a Rotation or a     four-dimenional vector representing the parameters of unit quaternion, and x is a     13-dimensional vector (or tuple),\n\nConverting to a State Vector\n\nAn RBState can be converted to a state vector for a RigidBody using     RBState(model::RBstate, x, [renorm=false])\n\n\n\n\n\n","category":"type"},{"location":"rigidbody.html#Building-a-State-Vector-1","page":"Rigid Bodies","title":"Building a State Vector","text":"","category":"section"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"RobotDynamics also provides several convenient methods for building rigid body state vectors. Identical to AbstractModel, RigidBody supports rand and zeros, which uniformly sample the space of rotations and provide the identity rotation, respectively.","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"RobotDynamics also provides the following method as a complement to parse_state that builds the state vector from the individual components:","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"build_state","category":"page"},{"location":"rigidbody.html#RobotDynamics.build_state","page":"Rigid Bodies","title":"RobotDynamics.build_state","text":"build_state(model::RigidBody{R}, x::RBState) where R\nbuild_state(model::RigidBody{R}, x::AbstractVector) where R\nbuild_state(model::RigidBody{R}, r, q, v, ω) where R\n\nBuild the state vector for model using the RBState x. If R <: UnitQuaternion this     returns x cast as an SVector, otherwise it will convert the quaternion in x to     a rotation of type R.\n\nAlso accepts as arguments any arguments that can be passed to the constructor of RBState.\n\n\n\n\n\n","category":"function"},{"location":"rigidbody.html#Advanced-Usage-1","page":"Rigid Bodies","title":"Advanced Usage","text":"","category":"section"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"RobotDynamics provides a few specialized methods for providing extra performance or customization.","category":"page"},{"location":"rigidbody.html#Specifying-the-Velocity-Frame-1","page":"Rigid Bodies","title":"Specifying the Velocity Frame","text":"","category":"section"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"Sometimes it is convenient to represent the linear velocity in the body frame instead of the global frame. This can be changed automatically for our Satellite model by defining","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"RobotDynamics.velocity_frame(::Satellite) = :body","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"which overrides the default setting of :world. Use this same method to query the current convention, especially in defining the forces and moments or wrenches methods on your model. Since the forces and moments of our satellite are not functions of the velocity, we don't need to change anything.","category":"page"},{"location":"rigidbody.html#Faster-Continuous-Dynamics-Jacobians-1","page":"Rigid Bodies","title":"Faster Continuous Dynamics Jacobians","text":"","category":"section"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"RobotDynamics has an analytical method for evaluating the continuous dynamics Jacobian for rigid bodies. If your application only uses the continuous dynamics Jacobian, there are two ways of getting significant performance improvements:","category":"page"},{"location":"rigidbody.html#.-Specify-the-analytical-wrench-Jacobian-1","page":"Rigid Bodies","title":"1. Specify the analytical wrench Jacobian","text":"","category":"section"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"For our Satellite, we can do this by defining","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"function RobotDynamics.wrench_jacobian!(F, model::Satellite, z)\n    x = state(z)\n    u = control(z)\n    q = orientation(model, x)\n    ir, iq, iv, iω, iu = RobotDynamics.gen_inds(model)\n    iF = SA[1,2,3]\n    iM = SA[4,5,6]\n    F[iF, iq] .= Rotations.∇rotate(q, u[iF])\n    F[iF, iu[iF]] .= RotMatrix(q)\n    for i = 1:3\n        F[iM[i], iu[i+3]] = 1\n    end\n    return F\nend","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"which gave us about a 60% improvement in runtime.","category":"page"},{"location":"rigidbody.html#.-Specify-the-Wrench-Jacobian-sparsity-1","page":"Rigid Bodies","title":"2. Specify the Wrench Jacobian sparsity","text":"","category":"section"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"You can get another improvement in performance by overwriting the following method:","category":"page"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"wrench_sparsity","category":"page"},{"location":"rigidbody.html#RobotDynamics.wrench_sparsity","page":"Rigid Bodies","title":"RobotDynamics.wrench_sparsity","text":"wrench_sparsity(model::RigidBody)\n\nSpecify the sparsity of the wrench Jacobian of model as a js = SMatrix{2,5,Bool,10}. The elements of js correspond to the block elements of the wrench Jacobian:\n\n[∂F/∂r ∂F/∂q ∂F/∂v ∂F/∂ω ∂F/∂u;\n ∂M/∂r ∂M/∂q ∂M/∂v ∂M/∂ω ∂M/∂u]\n\nwhere js[i,j] = false if the corresponding partial derivative is always zero.\n\nNote that this is only for performance improvement of continuous-time Jacobians of rigid bodies; specifying the sparsity is completely optional.\n\nExample\n\nFor a fully-actuated satellite where F = q*u[1:3] and M = u[4:6], the wrench sparsity would be\n\nSA[false true  false false true;\n   false false false false true]\n\n\n\n\n\n","category":"function"},{"location":"rigidbody.html#","page":"Rigid Bodies","title":"Rigid Bodies","text":"For the satellite we got a 75% improvement in runtime by specifying both the analytical wrench Jacobian and it's sparsity pattern.","category":"page"},{"location":"models.html#model_section-1","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"Pages = [\"models.md\"]","category":"page"},{"location":"models.html#Overview-1","page":"1. Setting up a Dynamics Model","title":"Overview","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"The Model type holds information about the dynamics of the system. All dynamics are assumed to be state-space models of the system of the form dotx = f(xu) where dotx is the state derivative, x an n-dimensional state vector, and u in an m-dimensional control input vector. The function f can be any nonlinear function.","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"Many numerical methods require discrete dynamics of the form x_k+1 = f(x_k u_k), where k is the time step. There many methods of performing this discretization, and RobotDynamics.jl offers several of the most common methods. See Model Discretization section for more information on discretizing dynamics, as well as how to define custom integration methods.","category":"page"},{"location":"models.html#Creating-a-New-Model-1","page":"1. Setting up a Dynamics Model","title":"Creating a New Model","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"To create a new model of a dynamical system, you need to define a new type that inherits from AbstractModel. You will need to then define only a few methods on your type. Let's say we want to create a model of the canonical cartpole. We start by defining our type:","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"struct Cartpole{T} <: AbstractModel\n    mc::T  # mass of the cart\n    mp::T  # mass of the pole\n    l::T   # length of the pole\n    g::T   # gravity\nend","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"It's often convenient to store any model parameters inside the new type (make sure they're concrete types!). If you need to store vectors or matrices, we highly recommend using StaticArrays, which are extremely fast and avoid memory allocations. For models with lots of parameters, we recommend Parameters.jl that makes it easy to specify default parameters.","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"We now just need to define two functions to complete the interface","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"import RobotDynamics: dynamics  # the dynamics function must be imported\n\nfunction dynamics(model::Cartpole, x, u)\n    mc = model.mc   # mass of the cart in kg (10)\n    mp = model.mp   # mass of the pole j(point mass at the end) in kg\n    l = model.l     # length of the pole in m\n    g = model.g     # gravity m/s^2\n\n    q  = x[SA[1,2]]\n    qd = x[SA[3,4]]\n\n    s = sin(q[2])\n    c = cos(q[2])\n\n    H = SA[mc+mp mp*l*c; mp*l*c mp*l^2]\n    C = SA[0 -mp*qd[2]*l*s; 0 0]\n    G = SA[0, mp*g*l*s]\n    B = SA[1, 0]\n\n    qdd = -H\\(C*qd + G - B*u[1])\n    return [qd; qdd]\nend\n\nRobotDynamics.state_dim(::Cartpole) = 4\nRobotDynamics.control_dim(::Cartpole) = 1","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"And voila! we have a new model.","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"We now have a few methods automatically available to us:","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"dynamics\njacobian!","category":"page"},{"location":"models.html#RobotDynamics.dynamics","page":"1. Setting up a Dynamics Model","title":"RobotDynamics.dynamics","text":"ẋ = dynamics(model, z::AbstractKnotPoint)\nẋ = dynamics(model, x, u, [t=0])\n\nCompute the continuous dynamics of a forced dynamical given the states x, controls u and time t (optional).\n\n\n\n\n\n","category":"function"},{"location":"models.html#RobotDynamics.jacobian!","page":"1. Setting up a Dynamics Model","title":"RobotDynamics.jacobian!","text":"∇f = jacobian!(∇f, model, z::AbstractKnotPoint)\n\nCompute the n × (n + m) Jacobian ∇f of the continuous-time dynamics using ForwardDiff. Only accepts an AbstractKnotPoint as input in order to avoid potential allocations associated with concatenation.\n\n\n\n\n\n","category":"function"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"We can also use size(model) to get (n,m), rand(model) to get a tuple of randomly-sampled state and control vectors, or zeros(model) to get 0-vectors of the state and control.","category":"page"},{"location":"models.html#Analytical-Jacobians-1","page":"1. Setting up a Dynamics Model","title":"Analytical Jacobians","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"Instead of relying on ForwardDiff to generate our dynamics Jacobian, we can instead overwrite the method ourselves by defining the function:","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"jacobian!(∇f, model::Cartpole, z::AbstractKnotPoint)","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"where ∇f is a n × (n+m) matrix and z is an AbstractKnotPoint.","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"warning: Warning\nBy default, RobotDynamics will NOT use the analytical continuous Jacobian when computing the discrete Jacobian, since our benchmarks have shown it is typically faster to let ForwardDiff compute the Jacobian directly on the discrete dynamics function, thereby avoiding multiple calls to jacobian!.","category":"page"},{"location":"models.html#Time-varying-systems-1","page":"1. Setting up a Dynamics Model","title":"Time-varying systems","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"RobotDynamics.jl also offers support for time-varying systems. Let's say for some reason the mass of our cartpole is decreasing linearly with time. We can model this with a slight modification to the dynamics function signature:","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"import RobotDynamics: dynamics\n\nstruct CartpoleTimeVarying{T} <: AbstractModel\n    mc::T  # initial mass of the cart\n    mp::T  # mass of the pole\n    l::T   # length of the pole\n    g::T   # gravity\nend\n\nfunction dynamics(model::CartpoleTimeVarying, x, u, t)  # note extra time parameter\n    mc = model.mc   # mass of the cart in kg (10)\n    mp = model.mp   # mass of the pole (point mass at the end) in kg\n    l = model.l     # length of the pole in m\n    g = model.g     # gravity m/s^2\n\n    # Change the mass of the cart with time\n    mc = mc - 0.01*t\n\n    q  = x[SA[1,2]]\n    qd = x[SA[3,4]]\n\n    s = sin(q[2])\n    c = cos(q[2])\n\n    H = SA[mc+mp mp*l*c; mp*l*c mp*l^2]\n    C = SA[0 -mp*qd[2]*l*s; 0 0]\n    G = SA[0, mp*g*l*s]\n    B = SA[1, 0]\n\n    qdd = -H\\(C*qd + G - B*u[1])\n    return [qd; qdd]\nend\n\nRobotDynamics.state_dim(::CartpoleTimeVarying) = 4\nRobotDynamics.control_dim(::CartpoleTimeVarying) = 1","category":"page"},{"location":"models.html#Discrete-Dynamical-Systems-1","page":"1. Setting up a Dynamics Model","title":"Discrete Dynamical Systems","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"Most models are assumed to be continuous in nature, and require some integration scheme (such as a Runge-Kutta method) to convert to discrete-time dynamics. However, some systems are naturally discrete or perhaps the user has a custom integration method already applied to their system. Instead of defining the continuous dynamics function, we can directly define the discrete dynamics instead with the predefined integration type PassThrough:","category":"page"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"# Define the discrete dynamics function\nfunction RobotDynamics.discrete_dynamics(::Type{PassThrough}, model::Cartpole,\n        x::StaticVector, u::StaticVector, t, dt)\n\n    mc = model.mc   # mass of the cart in kg (10)\n    mp = model.mp   # mass of the pole j(point mass at the end) in kg\n    l = model.l     # length of the pole in m\n    g = model.g     # gravity m/s^2\n\n    q  = x[SA[1,2]]\n    qd = x[SA[3,4]]\n\n    s = sin(q[2])\n    c = cos(q[2])\n\n    H = SA[mc+mp mp*l*c; mp*l*c mp*l^2]\n    C = SA[0 -mp*qd[2]*l*s; 0 0]\n    G = SA[0, mp*g*l*s]\n    B = SA[1, 0]\n\n    qdd = -H\\(C*qd + G - B*u[1])\n    xdot = [qd; qdd]\n    return x + xdot * dt  # simple Euler integration\nend","category":"page"},{"location":"models.html#Models-with-3D-Rotations-1","page":"1. Setting up a Dynamics Model","title":"Models with 3D Rotations","text":"","category":"section"},{"location":"models.html#","page":"1. Setting up a Dynamics Model","title":"1. Setting up a Dynamics Model","text":"RobotDynamics.jl offers support for models with non-Euclidean state vectors, such as 3D rotations, which live in SO(3) instead of mathbbR^4 (quaternions) or mathbbR^3 (Euler angles, Modified Rodrigues Parameters, etc.). See RigidBody section for more details.","category":"page"},{"location":"linearmodel.html#","page":"Linear Models","title":"Linear Models","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"linearmodel.html#Linear-Models-1","page":"Linear Models","title":"Linear Models","text":"","category":"section"},{"location":"linearmodel.html#","page":"Linear Models","title":"Linear Models","text":"RobotDynamics supports the easy construction of linear models. By defining a linear model, the relevant dynamics and jacobian functions are predefined for you. This can result in signicant speed ups compared to a naive  specification of a standard continuous model. ","category":"page"},{"location":"linearmodel.html#","page":"Linear Models","title":"Linear Models","text":"LinearModel\nLinearizedModel","category":"page"},{"location":"linearmodel.html#RobotDynamics.LinearModel","page":"Linear Models","title":"RobotDynamics.LinearModel","text":"LinearModel{n,m,T} <: AbstractModel\n\nA concrete type for creating efficient linear model representations. This model type will automatically define the continuous or discrete version of the dynamics and jacobian functions. Supports continuous/discrete, time invariant/varying, and affine models.\n\nConstructors\n\nLinearModel(A::AbstractMatrix, B::AbstractMatrix, [dt=0, use_static]) # time invariant\nLinearModel(A::AbstractMatrix, B::AbstractMatrix, d::AbstractVector, [dt=0, use_static]) # time invariant affine\nLinearModel(A::Vector{TA}, B::Vector{TB}, [times::AbstractVector, dt::Real=0, use_static]) # time varying\nLinearModel(A::Vector{TA}, B::Vector{TB}, d::Vector{Td}, [times::AbstractVector, dt=0, use_static]) # time varying affine\n\nLinearModel(n::Integer, m::Integer, [is_affine=false, times=1:0, dt=0, use_static]) # constructor with zero dynamics matrices\n\nBy default, the model is assumed to be continuous unless a non-zero dt is specified. For time varying models, searchsortedlast is  called on the times vector to get the discrete time index from the continuous time. The use_static keyword is automatically specified based on array size, but can be turned off in case of excessive compilation times.\n\n\n\n\n\n","category":"type"},{"location":"linearmodel.html#RobotDynamics.LinearizedModel","page":"Linear Models","title":"RobotDynamics.LinearizedModel","text":"LinearizedModel{M,L,T} <: AbstractModel\n\nA container for the linearized model that holds the full nonlinear model, the linearized model, and the trajectory of linearization points. The same dynamics and jacobian functions can still be called on the LinearizedModel type.\n\nConstructors\n\nLinearizedModel(nonlinear_model::AbstractModel, Z::AbstractTrajectory; kwargs...)\nLinearizedModel(nonlinear_model::AbstractModel, [z::AbstractKnotPoint]; kwargs...)\n\nLinearizes nonlinear_model about the trajectory Z or a single point z. If not specified, z is defined as the state and control defined by zeros(nonlinear_model).\n\nLinearization is, by default, on the continuous system.  \n\nKeyword Arguments\n\nis_affine - Linearize the system with an affine term, such that the new state is the same as the original state. See below for more details.\ndt - Time step. If not provided, defaults to the value in Z or z. Must be specified and non-zero for the system to be discretized. If dt = NaN, then the dt will be inferred from the trajectory (useful for variable step sizes).\nintegration - An explicit integration method. Must also specify a non-zero dt. \n\nIf is_affine = false, the dynamics are defined as: f(xu) approx f(x_0 u_0) + A delta x + B delta u\n\nwhich defines the error state delta x = x - x_0     as the state of the linearized system. Here A and B are the partial derivative     of the dynamics with respect to the state and control, respectively.\n\nIf is_affine = true, the form is an affine function of the form f(xu) approx A x + B u + d\n\nwhere d = f(x_0u_0) - A x_0 - B u_0, which maintains the same definition of the state.\n\n\n\n\n\n","category":"type"},{"location":"linearmodel.html#Linearizing-and-Discretizing-a-Model-(experimental)-1","page":"Linear Models","title":"Linearizing and Discretizing a Model (experimental)","text":"","category":"section"},{"location":"linearmodel.html#","page":"Linear Models","title":"Linear Models","text":"Many systems with complicated nonlinear dynamics can be simplified by linearizing them about a fixed point or a trajectory. This can allow the use of specialized and faster trajectory optimization methods for these linear systems. The functions that RobotDynamics provides also discretize the system. ","category":"page"},{"location":"linearmodel.html#","page":"Linear Models","title":"Linear Models","text":"linearize_and_discretize!\ndiscretize!\nupdate_trajectory!","category":"page"},{"location":"linearmodel.html#RobotDynamics.discretize!","page":"Linear Models","title":"RobotDynamics.discretize!","text":"discretize!(::Type{Q}, model::LinearizedModel, k)\n\nDiscretize the linearized model at time step k, using integration Q. \n\n\n\n\n\n","category":"function"},{"location":"linearmodel.html#RobotDynamics.update_trajectory!","page":"Linear Models","title":"RobotDynamics.update_trajectory!","text":"update_trajectory!(model::LinearizedModel, Z::AbstractTrajectory, integration::=DEFAULT_Q)\n\nUpdates the trajectory inside of the model and relinearizes (and discretizes for discrete      models) the model about the new trajectory.\n\n\n\n\n\n","category":"function"},{"location":"linearmodel.html#Example-1","page":"Linear Models","title":"Example","text":"","category":"section"},{"location":"linearmodel.html#","page":"Linear Models","title":"Linear Models","text":"Take for example the cartpole, which can be readily linearized about it's stable point. We can use the  LinearizedModel to easily find the linearized system.","category":"page"},{"location":"linearmodel.html#","page":"Linear Models","title":"Linear Models","text":"using RobotDynamics\nimport RobotDynamics: dynamics  # the dynamics function must be imported\nusing StaticArrays\n\nconst RD = RobotDynamics\n\nstruct Cartpole{T} <: AbstractModel\n    mc::T  # mass of the cart\n    mp::T  # mass of the pole\n    l::T   # length of the pole\n    g::T   # gravity\nend\n\nfunction dynamics(model::Cartpole, x, u)\n    mc = model.mc   # mass of the cart in kg (10)\n    mp = model.mp   # mass of the pole j(point mass at the end) in kg\n    l = model.l     # length of the pole in m\n    g = model.g     # gravity m/s^2\n\n    q  = x[SA[1,2]]\n    qd = x[SA[3,4]]\n\n    s = sin(q[2])\n    c = cos(q[2])\n\n    H = SA[mc+mp mp*l*c; mp*l*c mp*l^2]\n    C = SA[0 -mp*qd[2]*l*s; 0 0]\n    G = SA[0, mp*g*l*s]\n    B = SA[1, 0]\n\n    qdd = -H\\(C*qd + G - B*u[1])\n    return [qd; qdd]\nend\n\nRD.state_dim(::Cartpole) = 4\nRD.control_dim(::Cartpole) = 1\n\nnonlinear_model = Cartpole(1.0, 1.0, 1.0, 9.81)\nn = state_dim(nonlinear_model)\nm = control_dim(nonlinear_model)\n\n# stationary point for the cartpole around which to linearize\nx̄ = @SVector [0., π, 0., 0.]\nū = @SVector [0.0]\ndt = 0.01\nknot_point = KnotPoint(x̄, ū, dt)\n\n# creates a new LinearizedModel around stationary point\nlinear_model = RD.LinearizedModel(nonlinear_model, knot_point, \n    dt=dt, integration=Exponential)\n\nδx = @SVector zeros(n)\nδu = @SVector zeros(m)\n\n# outputs linearized dynamics!\nδxₖ₊₁ = discrete_dynamics(PassThrough, linear_model, δx, δu, 0.0, dt) \n\n@assert δxₖ₊₁ ≈ zeros(n)\n\nF = RD.DynamicsJacobian(n,m)\ndiscrete_jacobian!(PassThrough, F, linear_model, knot_point)\n\n@show A = RD.get_A(F)\n@show B = RD.get_B(F)\n","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"discretization.html#Discretization-1","page":"Discretization","title":"Discretization","text":"","category":"section"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"This page gives details on the methods for evaluating discretized dynamics, as well as instructions on how to define a custom integration method.","category":"page"},{"location":"discretization.html#Model-Discretization-1","page":"Discretization","title":"Model Discretization","text":"","category":"section"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"With a model defined, we can compute the discrete dynamics and discrete dynamics Jacobians for an Implicit integration rule with the following methods","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"discrete_dynamics\ndiscrete_jacobian!","category":"page"},{"location":"discretization.html#RobotDynamics.discrete_dynamics","page":"Discretization","title":"RobotDynamics.discrete_dynamics","text":"Compute the discretized dynamics of model using explicit integration scheme Q<:QuadratureRule.\n\nMethods:\n\nx′ = discrete_dynamics(model, model, z)  # uses RK3 as the default integration scheme\nx′ = discrete_dynamics(Q, model, x, u, t, dt)\nx′ = discrete_dynamics(Q, model, z::KnotPoint)\n\nThe default integration scheme is stored in TrajectoryOptimization.DEFAULT_Q\n\n\n\n\n\n","category":"function"},{"location":"discretization.html#RobotDynamics.discrete_jacobian!","page":"Discretization","title":"RobotDynamics.discrete_jacobian!","text":"∇f = discrete_jacobian!(Q, ∇f, model, z::AbstractKnotPoint)\n\nCompute the n × (n+m) discrete dynamics Jacobian ∇f of model using explicit integration scheme Q<:QuadratureRule.\n\n\n\n\n\n","category":"function"},{"location":"discretization.html#Integration-Schemes-1","page":"Discretization","title":"Integration Schemes","text":"","category":"section"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"RobotDynamics.jl has already defined a handful of integration schemes for computing discrete dynamics. The integration schemes are specified as abstract types, so that methods can efficiently dispatch based on the integration scheme selected. Here is the current set of implemented types:","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"QuadratureRule\nExplicit\nRK2\nRK3\nRK4\nExponential\nPassThrough\nImplicit\nHermiteSimpson","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"QuadratureRule\nRobotDynamics.Explicit\nRK2\nRK3\nRK4\nExponential\nPassThrough\nRobotDynamics.Implicit\nHermiteSimpson","category":"page"},{"location":"discretization.html#RobotDynamics.QuadratureRule","page":"Discretization","title":"RobotDynamics.QuadratureRule","text":"Integration rule for approximating the continuous integrals for the equations of motion\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#RobotDynamics.Explicit","page":"Discretization","title":"RobotDynamics.Explicit","text":"Integration rules of the form x′ = f(x,u), where x′ is the next state\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#RobotDynamics.RK2","page":"Discretization","title":"RobotDynamics.RK2","text":"Second-order Runge-Kutta method with zero-order-old on the controls (i.e. midpoint)\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#RobotDynamics.RK3","page":"Discretization","title":"RobotDynamics.RK3","text":"Second-order Runge-Kutta method with zero-order-old on the controls\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#RobotDynamics.RK4","page":"Discretization","title":"RobotDynamics.RK4","text":"Fourth-order Runge-Kutta method with zero-order-old on the controls\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#RobotDynamics.Exponential","page":"Discretization","title":"RobotDynamics.Exponential","text":"Exponential integration for linear systems with ZOH on controls.\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#RobotDynamics.PassThrough","page":"Discretization","title":"RobotDynamics.PassThrough","text":"Integration type for systems with user defined discrete dynamics.\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#RobotDynamics.Implicit","page":"Discretization","title":"RobotDynamics.Implicit","text":"Integration rules of the form x′ = f(x,u,x′,u′), where x′,u′ are the states and controls at the next time step.\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#RobotDynamics.HermiteSimpson","page":"Discretization","title":"RobotDynamics.HermiteSimpson","text":"Third-order Runge-Kutta method with first-order-hold on the controls\n\n\n\n\n\n","category":"type"},{"location":"discretization.html#Defining-a-New-Integration-Scheme-1","page":"Discretization","title":"Defining a New Integration Scheme","text":"","category":"section"},{"location":"discretization.html#Explicit-Methods-1","page":"Discretization","title":"Explicit Methods","text":"","category":"section"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"Explicit integration schemes are understandably simpler, since the output is not a function of itself, as is the case with implict schemes. As such, as a minimum, the user only needs to define the following method for a new rule MyQ:","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"abstract type MyQ <: RobotDynamics.Explicit end\nx′ = discrete_dynamics(::Type{MyQ}, model::AbstractModel, x, u, t, dt)","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"which will make calls to the continuous-time dynamics function dynamics(model, x, u, t).","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"Below is an example of the default integration method RK3, a third-order Runge-Kutta method:","category":"page"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"function discrete_dynamics(::Type{RK3}, model::AbstractModel,\n\t\tx::StaticVector, u::StaticVector, t, dt)\n    k1 = dynamics(model, x,             u, t       )*dt;\n    k2 = dynamics(model, x + k1/2,      u, t + dt/2)*dt;\n    k3 = dynamics(model, x - k1 + 2*k2, u, t + dt  )*dt;\n    x + (k1 + 4*k2 + k3)/6\nend","category":"page"},{"location":"discretization.html#Implicit-Methods-(experimental)-1","page":"Discretization","title":"Implicit Methods (experimental)","text":"","category":"section"},{"location":"discretization.html#","page":"Discretization","title":"Discretization","text":"Incorporating implicit integration methods is still under development (great option for     someone looking to contribute!).","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"liemodel.html#Models-with-Rotations-1","page":"Models with Rotations","title":"Models with Rotations","text":"","category":"section"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"In robotics, the state of our robot often depends on one or more arbitrary 3D rotations (a.k.a. orientation, attitude). Effectively representing the non-trivial group structure of rotations has been a topic of study for over 100 years, and as a result many parameterizations exists. RobotDynamics supports the types defined in Rotations.jl.","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"The LieGroupModel type allows users to abstract away the particular rotation representation used and will automatically create efficient methods to handle the potentially different state dimensions that result. Additionally, it defines methods for operating on the error state, which for rotations is always three-dimensional. See the discussion in the Rotaitons.jl README for more information on the error state.","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"compat: Compat\nRobotDynamics requires v1.0 or higher of Rotations.jl","category":"page"},{"location":"liemodel.html#Defining-a-LieGroupModel-1","page":"Models with Rotations","title":"Defining a LieGroupModel","text":"","category":"section"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"We define a LieGroupModel very similarly to that of a standard model. For this example, let's assume we are modeling a constellation of 2 satellites and we only care about the attitude dynamics. We will define our state to be [q1, ω1, q2, ω2] where qi and ωi are the orientation  and angular velocity of the ith satellite, respectively.","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"We start by defining our new type and our dynamics function","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"struct SatellitePair{R,T} <: LieGroupModel\n    J1::SMatrix{3,3,T,9}   # inertia of satellite 1\n    J2::SMatrix{3,3,T,9}   # inertia of satellite 2\nend\n\nfunction RobotDynamics.dynamics(model::SatellitePair, x, u)\n    vs = RobotDynamics.vec_states(model, x)  # extract \"vector\" states\n    qs = RobotDynamics.rot_states(model, x)  # extract attitude states\n    ω1 = vs[2]  # offset index by 1 since there are now \"vector\" states before the first quaternion\n    ω2 = vs[3]\n    q1 = qs[1]\n    q2 = qs[2]\n\n    J1, J2 = model.J1, model.J2\n    u1 = u[SA[1,2,3]]\n    u2 = u[SA[4,5,6]]\n    ω1dot = J1\\(u1 - ω1 × (J1 * ω1))\n    ω2dot = J2\\(u2 - ω2 × (J2 * ω2))\n    q1dot = Rotations.kinematics(q1, ω1)\n    q2dot = Rotations.kinematics(q2, ω2)\n    SA[\n        q1dot[1], q1dot[2], q1dot[3], q1dot[4],\n        ω1dot[1], ω1dot[2], ω1dot[3],\n        q2dot[1], q2dot[2], q2dot[3], q2dot[4],\n        ω2dot[1], ω2dot[2], ω2dot[3],\n    ]\nend\n\nRobotDynamics.control_dim(::SatellitePair) = 6","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"Before defining the functions vec_states and rot_states, we will define the type LieState, which defines how our state vector is stacked or partitioned. The LieState only needs to know how many \"vector\" or \"non-rotation\" states exist, and where the rotations are placed in the state vector. In our example, we have a rotation, followed by 3 \"vector\" states, followed by a rotation, followed by 3 \"vector\" states, so we would define our LieState to be","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"RobotDynamics.LieState(::SatellitePair{R}) where R = RobotDynamics.LieState(R, (0,3,3))","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"which means we have a state with 0 vector states at the beginning, followed by a rotation, followed by 3 vector states, followed by a rotation, followed by 3 vector states, and the rotation type is R.","category":"page"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"With this partitioning in mind, we can now understand the behavior of vec_states and rot_states, which simply extract the vector and attitude parts of the state as tuples of SVectors.","category":"page"},{"location":"liemodel.html#LieGroupModel-API-1","page":"Models with Rotations","title":"LieGroupModel API","text":"","category":"section"},{"location":"liemodel.html#","page":"Models with Rotations","title":"Models with Rotations","text":"RobotDynamics.LieGroupModel\nRobotDynamics.LieState\nRobotDynamics.QuatState\nRobotDynamics.vec_states\nRobotDynamics.rot_states","category":"page"},{"location":"liemodel.html#RobotDynamics.LieGroupModel","page":"Models with Rotations","title":"RobotDynamics.LieGroupModel","text":"LieGroupModel <: AbstractModel\n\nAbstraction of a dynamical system whose state contains at least one arbitrary rotation.\n\n\n\n\n\n","category":"type"},{"location":"liemodel.html#RobotDynamics.LieState","page":"Models with Rotations","title":"RobotDynamics.LieState","text":"LieState{R,P}\n\nSpecifies a state with rotational components mixed in with standard vector components. All rotational components are assumed to be parameterizations of 3D rotations.\n\nParameters\n\nR <: Rotation is the rotational representation used in the state vector. Must have\n\nparams(::Type{R}) defined, which returns the number of parameters used by the rotation, as well a constructor that takes each parameter as a separate scalar argument.\n\nP <: Tuple{Vararg{Int}} is a tuple of integers specifying the partitioning of the state\n\nvector. Each element of P specifies the length of the vector component between the rotational components, and P[1] and P[end] specify the number of vector states at the beginning and end of the state vector.\n\nExamples\n\nIf we want to construct a state vector like the following: [v3, q, v2, q, v3] where v2 and v3 and vector components of length 2 and 3, respectively, and q is a 4-dimensional unit quaternion. The LieState for this state vector would be LieState{UnitQuaternion{Float64},3,2,3}. The length should be (3+4+2+4+3) = 16, which can be verified by length(s::LieState).\n\nConstructors\n\nLieState(::Type{R}, P::Tuple{Vararg{Int}})\nLieState(::Type{R}, p1::Int, p2::Int, p3::Int...)\n\n\n\n\n\n","category":"type"},{"location":"liemodel.html#RobotDynamics.QuatState","page":"Models with Rotations","title":"RobotDynamics.QuatState","text":"QuatState(n::Int, Q::StaticVector{<:Any,Int})\nQuatState(n::Int, Q::NTuple{<:Any,Int})\n\nCreate a n-dimensional LieState assuming R = UnitQuaternion{Float64} and Q[i] is the first index of each quaternion in the state vector.\n\nExample\n\nIf we want to construct a state vector like the following: [v3, q, v2, q, v3] where v2 and v3 and vector components of length 2 and 3, respectively, and q is a 4-dimensional unit quaternion. Since the first quaternion starts at index 4, and the second starts at index 10, Q = [4,10]. The entire length of the vector is n = 16 = 3 + 4 + 2 + 4 + 3, so we would call QuatState(16, SA[4,10]).\n\n\n\n\n\n","category":"function"},{"location":"liemodel.html#RobotDynamics.vec_states","page":"Models with Rotations","title":"RobotDynamics.vec_states","text":"vec_states(model::LieGroupModel, x)\nvec_states(s::LieState, x)\n\nExtracts the \"vector\" states out of the state vector x for a LieGroupModel. Returns a tuple v of SVectors, where length(v[i]) is equal to the length specified by the LieState.\n\n\n\n\n\n","category":"function"},{"location":"liemodel.html#RobotDynamics.rot_states","page":"Models with Rotations","title":"RobotDynamics.rot_states","text":"vec_states(model::LieGroupModel, x)\nvec_states(s::LieState, x)\n\nExtracts the rotations out of the state vector x for a LieGroupModel. Returns a tuple rotations, whose type matches the rotation type specified in the LieState.\n\n\n\n\n\n","category":"function"},{"location":"index.html#RobotDynamics.jl-1","page":"Introduction","title":"RobotDynamics.jl","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Welcome to RobotDynamics.jl! This package is dedicated to providing a convenient interface for defining the dynamics of forced dynamical systems, such as robots.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"This package also provides many efficient methods for evaluating dynamics, their Jacobians, and their discrete-time versions for use in optimization packages such as TrajectoryOptimization.jl.","category":"page"},{"location":"knotpoints.html#KnotPoint-type-1","page":"KnotPoint type","title":"KnotPoint type","text":"","category":"section"},{"location":"knotpoints.html#","page":"KnotPoint type","title":"KnotPoint type","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"knotpoints.html#","page":"KnotPoint type","title":"KnotPoint type","text":"A common way of dealing with trajectories of forced dynamical systems, especially in optimization, is to represent a trajectory with a fixed number of \"knot points\", typically distributed evenly over time. Each point records the states, controls, time, and time step to the next point. It is often convenient to store all this information together, which is the purpose of the AbstractKnotPoint type. Additionally, it is almost always more efficient to index into a concatenated vector than it is to concatenate two smaller vectors, so the states and controls are stacked together in a single  n+m-dimensional vector.","category":"page"},{"location":"knotpoints.html#","page":"KnotPoint type","title":"KnotPoint type","text":"RobotDynamics.jl defines a couple different implementations of the AbstractKnotPoint interface, which can be useful depending on the application.","category":"page"},{"location":"knotpoints.html#Types-1","page":"KnotPoint type","title":"Types","text":"","category":"section"},{"location":"knotpoints.html#","page":"KnotPoint type","title":"KnotPoint type","text":"AbstractKnotPoint\nGeneralKnotPoint\nKnotPoint\nStaticKnotPoint","category":"page"},{"location":"knotpoints.html#RobotDynamics.AbstractKnotPoint","page":"KnotPoint type","title":"RobotDynamics.AbstractKnotPoint","text":"AbstractKnotPoint{T,n,m}\n\nStores the states, controls, time, and time step at a single point along a trajectory of a forced dynamical system with n states and m controls.\n\nInterface\n\nAll instances of AbstractKnotPoint should support the following methods:\n\nstate(z)::StaticVector{n}     # state vector\ncontrol(z)::StaticVector{m}   # control vector\nz.t::Real                     # time\nz.dt::Real                    # time to next point (time step)\n\nBy default, it is assumed that if z.dt == 0 the point is the last point in the trajectory.\n\nAlternatively, the methods state and control will be automatically defined if the following fields are present:\n\nz.z: the stacked vector [x;u]\nz._x: the indices of the states, such that x = z.z[z._x]\nz._u: the indices of the controls, such that x = u.z[z._u]\n\n\n\n\n\n","category":"type"},{"location":"knotpoints.html#RobotDynamics.GeneralKnotPoint","page":"KnotPoint type","title":"RobotDynamics.GeneralKnotPoint","text":"GeneralKnotPoint{T,n,m,V} <: AbstractKnotPoint{T,n,m}\n\nA mutable instantiation of the AbstractKnotPoint interface where the joint vector z = [x;u] is represented by a type V.\n\nConstructors\n\nGeneralKnotPoint(n::Int, m::Int, z::AbstractVector, dt, [t=0])\nGeneralKnotPoint(z::V, _x::SVector{n,Int}, _u::SVector{m,Int}, dt::T, t::T)\nKnotPoint(z::V, _x::SVector{n,Int}, _u::SVector{m,Int}, dt::T, t::T)\n\n\n\n\n\n","category":"type"},{"location":"knotpoints.html#RobotDynamics.KnotPoint","page":"KnotPoint type","title":"RobotDynamics.KnotPoint","text":"KnotPoint{T,n,m,nm}\n\nA GeneralKnotPoint whose stacked vector z = [x;u] is represented by an SVector{nm,T} where nm = n+m.\n\nSetters\n\nUse the following methods to set values in a KnotPoint:\n\nset_state!(z::KnotPoint, x)\nset_control!(z::KnotPoint, u)\nz.t = t\nz.dt = dt\n\nConstructors\n\nKnotPoint(x, u, dt, [t=0.0])\nKnotPoint(x, m, [t=0.0])  # for terminal knot point\n\n\n\n\n\n","category":"type"},{"location":"knotpoints.html#RobotDynamics.StaticKnotPoint","page":"KnotPoint type","title":"RobotDynamics.StaticKnotPoint","text":"StaticKnotPoint{T,n,m,nm} <: AbstractKnotPoint{T,n,m}\n\nAn immutable AbstractKnotPoint whose stacked vector is represented by an SVector{nm,T} where nm = n+m. Since isbits(z::StaticKnotPoint) = true, these can be created very efficiently and with zero allocations.\n\nConstructors\n\nStaticKnotPoint(z::SVector{nm}, _x::SVector{n,Int}, _u::SVector{m,Int}, dt::Float64, t::Float64)\nStaticKnotPoint(x::SVector{n}, u::SVector{m}, [dt::Real=0.0, t::Real=0.0])\nStaticKnotPoint(z0::AbstractKnotPoint, z::AbstractVector)\n\nwhere the last constructor uses another AbstractKnotPoint to create a StaticKnotPoint using the stacked state-control vector z. If length(z) == n, the constructor will automatically append m zeros.\n\n\n\n\n\n","category":"type"},{"location":"knotpoints.html#Methods-1","page":"KnotPoint type","title":"Methods","text":"","category":"section"},{"location":"knotpoints.html#","page":"KnotPoint type","title":"KnotPoint type","text":"All AbstractKnotPoint types support the following methods:","category":"page"},{"location":"knotpoints.html#","page":"KnotPoint type","title":"KnotPoint type","text":"state\ncontrol\nis_terminal\nget_z\nset_state!\nset_control!\nset_z!","category":"page"},{"location":"knotpoints.html#RobotDynamics.state","page":"KnotPoint type","title":"RobotDynamics.state","text":"state(::AbstractKnotPoint)\n\nReturn the n-dimensional state vector\n\n\n\n\n\n","category":"function"},{"location":"knotpoints.html#RobotDynamics.control","page":"KnotPoint type","title":"RobotDynamics.control","text":"control(::AbstractKnotPoint)\n\nReturn the m-dimensional control vector\n\n\n\n\n\n","category":"function"},{"location":"knotpoints.html#RobotDynamics.is_terminal","page":"KnotPoint type","title":"RobotDynamics.is_terminal","text":"is_terminal(::AbstractKnotPoint)::Bool\n\nDetermine if the knot point is the terminal knot point, which is the case when z.dt == 0.\n\n\n\n\n\n","category":"function"},{"location":"knotpoints.html#RobotDynamics.get_z","page":"KnotPoint type","title":"RobotDynamics.get_z","text":"get_z(::AbstractKnotPoint)\n\nReturns the stacked state-control vector z, or just the state vector if is_terminal(z) == true.\n\n\n\n\n\n","category":"function"},{"location":"knotpoints.html#RobotDynamics.set_state!","page":"KnotPoint type","title":"RobotDynamics.set_state!","text":"set_state!(z::AbstractKnotPoint, x::AbstractVector)\n\nSet the state in z to x.\n\n\n\n\n\n","category":"function"},{"location":"knotpoints.html#RobotDynamics.set_control!","page":"KnotPoint type","title":"RobotDynamics.set_control!","text":"set_control!(z::AbstractKnotPoint, u::AbstractVector)\n\nSet the controls in z to u.\n\n\n\n\n\n","category":"function"},{"location":"knotpoints.html#RobotDynamics.set_z!","page":"KnotPoint type","title":"RobotDynamics.set_z!","text":"set_z!(z::AbstractKnotPoint, z_::AbstractVector)\n\nSet both the states and controls in z from the stacked state-control vector z_, unless is_terminal(z), in which case z_ is assumed to be the terminal states.\n\n\n\n\n\n","category":"function"},{"location":"knotpoints.html#Mathematical-Operations-1","page":"KnotPoint type","title":"Mathematical Operations","text":"","category":"section"},{"location":"knotpoints.html#","page":"KnotPoint type","title":"KnotPoint type","text":"All AbstractKnotPoint types support addition between two knot points, addition of a knot point and a vector of length n+m, and multiplication with a scalar, all of which will return a StaticKnotPoint.","category":"page"},{"location":"dynamics_evaluation.html#model_section-1","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"","category":"section"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"Pages = [\"dynamics_evaluation.md\"]","category":"page"},{"location":"dynamics_evaluation.html#Overview-1","page":"2. Evaluating the Dynamics","title":"Overview","text":"","category":"section"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"Once we have a model defined as detailed on the previous page, we can query both the continuous and discrete dynamics, and have access to some additional, useful methods.","category":"page"},{"location":"dynamics_evaluation.html#Querying-the-Continuous-Dynamics-1","page":"2. Evaluating the Dynamics","title":"Querying the Continuous Dynamics","text":"","category":"section"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"We can evaluate the continuous dynamics using one of the following methods:","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"ẋ = dynamics(model, z)\nẋ = dynamics(model, x, u)\nẋ = dynamics(model, x, u, t)","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"where z is an AbstractKnotPoint, x is the n-dimensional state vector, u is the m-dimensional control vector, and t is the positive scalar independent variable, typically time. For best performance, x and u should be SVectors.","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"We can evaluate the continuous time dynamics Jacobian using the method","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"jacobian!(∇f, model, z)","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"where ∇f is an n × (n+m) matrix. Note that the Jacobian methods require an AbstractKnotPoint, since this eliminates unnecessary concatenation and subsequent memory allocations when using ForwardDiff.","category":"page"},{"location":"dynamics_evaluation.html#The-DynamicsJacobian-type-1","page":"2. Evaluating the Dynamics","title":"The DynamicsJacobian type","text":"","category":"section"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"While the dynamics Jacobian ∇f can be any AbstractMatrix, RobotDynamics provides the DynamicsJacobian type that has some convenient constructors and provides access to the individual partial derivatives:","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"DynamicsJacobian","category":"page"},{"location":"dynamics_evaluation.html#RobotDynamics.DynamicsJacobian","page":"2. Evaluating the Dynamics","title":"RobotDynamics.DynamicsJacobian","text":"DynamicsJacobian{n,nm,T}\n\nCustom n × (n+m) matrix specifying a dynamics Jacobian for a forced dynamical system with n states and m controls. The Jacobian is structured as [∂x ∂u] where x and u are the state and control vectors, respectively.\n\nThe DynamicsJacobian D provides access to the partial derivatives A = ∂x  and B = ∂u via direct access D.A and D.B, returning a view into the underlying Matrix, or\n\nRobotDynamics.get_A(D)\nRobotDynamics.get_B(D)\n\nwhich return an SMatrix. Note that this method should be used with caution for systems with large state and/or control dimensions.\n\nConstructors\n\nDynamicsJacobian(model::AbstractModel)\nDynamicsJacobian(n::Int, m::Int)\nDynamicsJacobian(D::StaticMatrix)\n\nwhere D is a StaticMatrix of appropriate size. Since DynamicsJacobian implements the StaticMatrix interface, is also supports all the constructors and operations inherent to a StaticMatrix.\n\n\n\n\n\n","category":"type"},{"location":"dynamics_evaluation.html#Querying-Discrete-Dynamics-1","page":"2. Evaluating the Dynamics","title":"Querying Discrete Dynamics","text":"","category":"section"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"The discrete dynamics can be evaluated using methods analogous to those used to evaluate the continuous dynamics, except we now need to specify the integration method and the time step.","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"x′ = discrete_dynamics(::Type{Q}, model, z)\nx′ = discrete_dynamics(::Type{Q}, model, x, u, t, dt)","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"where Q is a QuadratureRule. See Discretization for more information on the integration methods defined in RobotDynamics.","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"When evaluating discrete dynamics, one can also use the propagate_dynamics method that updates the state of the next KnotPoint:","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"propagate_dynamics","category":"page"},{"location":"dynamics_evaluation.html#RobotDynamics.propagate_dynamics","page":"2. Evaluating the Dynamics","title":"RobotDynamics.propagate_dynamics","text":"propagate_dynamics(::Type{Q}, model, z_, z)\n\nEvaluate the discrete dynamics of model using integration method Q at knot point z, storing the result in the states of knot point z_.\n\nUseful for propagating dynamics along a trajectory of knot points.\n\n\n\n\n\n","category":"function"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"The discrete dynamics Jacobian is similarly evaluated using","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"discrete_jacobian!(::Type{Q}, ∇f, model, z)","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"If the integration method is not passed in as the first argument, the default integration method RK3 will be used.","category":"page"},{"location":"dynamics_evaluation.html#Other-Methods-1","page":"2. Evaluating the Dynamics","title":"Other Methods","text":"","category":"section"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"All AbstractModels provide a few functions for generating state and control vectors directly from the model:","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"x,u = zeros(model)\nx,u = rand(model)\nx,u = fill(model, value)","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"The Base.size method is also overloaded as a shortcut for returning state_dim(model) and control_dim(model) as a tuple:","category":"page"},{"location":"dynamics_evaluation.html#","page":"2. Evaluating the Dynamics","title":"2. Evaluating the Dynamics","text":"n,m = size(model)","category":"page"}]
}
