var documenterSearchIndex = {"docs":
[{"location":"knotpoints.html#Knot-Points-1","page":"Knot Points","title":"Knot Points","text":"","category":"section"},{"location":"knotpoints.html#","page":"Knot Points","title":"Knot Points","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"knotpoints.html#","page":"Knot Points","title":"Knot Points","text":"RobotDynamics describes forced dynamical systems whose behavior is defined by an  n-dimensional state vector x and an m-dimensional control vector u. We often represent trajectories of the systems by sampling a continuous trajectory,  where each sample has a state, control, time, and the time step between the current  sample and the next. Following terminology from direct trajectory optimization methods such as direct collocation, we refer to each sample as \"knot point.\" This page  describes the abstract type AbstractKnotPoint, as well a couple different  implementations of the abstraction provided by the package. These types should be  sufficient for most use cases: further instantiations of the AbstractKnotPoint type  shouldn't be needed in most cases. ","category":"page"},{"location":"knotpoints.html#The-AbstractKnotPoint-Type-1","page":"Knot Points","title":"The AbstractKnotPoint Type","text":"","category":"section"},{"location":"knotpoints.html#","page":"Knot Points","title":"Knot Points","text":"AbstractKnotPoint\ngetstate\ngetcontrol\nstate\ncontrol\nsetdata!\nsetstate!\nsetcontrol!\nis_terminal\nvectype\ndatatype","category":"page"},{"location":"knotpoints.html#RobotDynamics.AbstractKnotPoint","page":"Knot Points","title":"RobotDynamics.AbstractKnotPoint","text":"AbstractKnotPoint{Nx,Nu,V,T}\n\nStores the states, controls, time, and time step at a single point along a trajectory of a forced dynamical system with n states and m controls.\n\nInterface\n\nAll instances of AbstractKnotPoint should support the following methods:\n\nRequired methods  Brief description\nstate_dim(z)  State vector dimension\ncontrol_dim(z)  Control vector dimension\nget_data(z)::V  Get the vector of concatenated states and controls\nOptional Methods Default definition Brief description\ntime(z) z.t Get the time\ntimestep(z) z.dt Get the time step\nsettime!(z, t) z.t = t Set the time\nsettimestep!(z, dt) z.dt = dt Set the time step\nis_terminal(z) timestep(z) === zero(datatype(z)) \n\nMethods\n\nGiven the above interface, the following methods are defined for an AbstractKnotPoint:\n\ndims(z)\ngetstate\ngetcontrol\nstate\ncontrol\nstate\nsetdata!\nsetstate!\nsetcontrol!\nis_terminal\ndatatype\nvectype\n\n\n\n\n\n","category":"type"},{"location":"knotpoints.html#RobotDynamics.getstate","page":"Knot Points","title":"RobotDynamics.getstate","text":"getstate(z, v)\n\nExtract the state vector from a vector v. Returns a view into the matrix by default,  or an SVector if the knot point uses SVectors.\n\n\n\n\n\n","category":"function"},{"location":"knotpoints.html#RobotDynamics.getcontrol","page":"Knot Points","title":"RobotDynamics.getcontrol","text":"getcontrol(z, v)\n\nExtract the state vector from a vector v. Returns a view into the matrix by default,  or an SVector if the knot point uses SVectors. If the knot point is a terminal  knot point, it will return an empty view or an SVector of zeros.\n\n\n\n\n\n","category":"function"},{"location":"knotpoints.html#RobotDynamics.state","page":"Knot Points","title":"RobotDynamics.state","text":"state(z)\n\nGet the state vector. Returns either a view or an SVector.\n\n\n\n\n\n","category":"function"},{"location":"knotpoints.html#RobotDynamics.control","page":"Knot Points","title":"RobotDynamics.control","text":"control(z)\n\nGet the control vector. Returns either a view of an SVector. For a terminal knot point it will return an empty view or an SVector of zeros.\n\n\n\n\n\n","category":"function"},{"location":"knotpoints.html#RobotDynamics.setdata!","page":"Knot Points","title":"RobotDynamics.setdata!","text":"setdata!(z, v)\n\nSet the data vector, or the concatenated vector of states and controls.\n\n\n\n\n\nsetdata!(Z, V)\n\nSet the concatenated state and control vector for each knot point in the trajectory Z.  V may be either a vector of vectors or a 2D matrix.\n\n\n\n\n\n","category":"function"},{"location":"knotpoints.html#RobotDynamics.setstate!","page":"Knot Points","title":"RobotDynamics.setstate!","text":"setstate!(z, x)\n\nSet the state vector for an AbstractKnotPoint.\n\n\n\n\n\n","category":"function"},{"location":"knotpoints.html#RobotDynamics.setcontrol!","page":"Knot Points","title":"RobotDynamics.setcontrol!","text":"setcontrol!(z, x)\n\nSet the control vector for an AbstractKnotPoint.\n\n\n\n\n\n","category":"function"},{"location":"knotpoints.html#RobotDynamics.is_terminal","page":"Knot Points","title":"RobotDynamics.is_terminal","text":"is_terminal(z)\n\nDetermines if the knot point z is a terminal knot point with no  controls, only state information. By default a knot point is assumed to be a  terminal knot point if the time step is zero. By convention, if the last  knot point has control values assigned (for example, when doing first-order  hold on the controls), the final time step is set to infinity instead of zero.\n\n\n\n\n\n","category":"function"},{"location":"knotpoints.html#RobotDynamics.vectype","page":"Knot Points","title":"RobotDynamics.vectype","text":"vectype(x)\n\nGet the vector type used by the object x. Used to allow either static or  dynamic arrays in structs such as AbstractKnotPoint.\n\n\n\n\n\n","category":"function"},{"location":"knotpoints.html#RobotDynamics.datatype","page":"Knot Points","title":"RobotDynamics.datatype","text":"datatype(x)\n\nGet the numeric data type used by the object x. Typically a floating point data type.\n\n\n\n\n\n","category":"function"},{"location":"knotpoints.html#Concrete-knot-point-types-1","page":"Knot Points","title":"Concrete knot point types","text":"","category":"section"},{"location":"knotpoints.html#","page":"Knot Points","title":"Knot Points","text":"KnotPoint\nStaticKnotPoint","category":"page"},{"location":"knotpoints.html#RobotDynamics.KnotPoint","page":"Knot Points","title":"RobotDynamics.KnotPoint","text":"KnotPoint{Nx,Nu,V,T}\n\nA mutable AbstractKnotPoint with Nx states, Nu controls, stored using  a vector type V with data type T. Since the struct is mutable, the time, timestep,  and data can all be changed, which can be very efficient when the data being stored  as an SVector.\n\nConstructors\n\nKnotPoint{n,m}(v, t, dt)\nKnotPoint{n,m}(x, u, t, dt)\nKnotPoint{n,m}(n, m, v, t, dt) \nKnotPoint(n, m, v, t, dt)       # create a KnotPoint{Any,Any}\nKnotPoint(x, u, t, dt)\n\nThe last method will create a KnotPoint{Any,Any} if x and u are not StaticVectors.\n\nThe vector type V can be queried using vectype(z).\n\n\n\n\n\n","category":"type"},{"location":"knotpoints.html#RobotDynamics.StaticKnotPoint","page":"Knot Points","title":"RobotDynamics.StaticKnotPoint","text":"StaticKnotPoint\n\nA static version of KnotPoint. Uses all of the same methods and constructors,  but also adds the following methods:\n\nStaticKnotPoint(z, v)\n\nwhich creates a new StaticKnotPoint using the information from the AbstractKnotPoint z, but using data from v. Useful for creating temporary knot points from existing ones  without any runtime allocations.\n\nThe following methods are similar to their mutable versions, but create a new  StaticKnotPoint:\n\nsetdata\nsetstate\nsetcontrol\n\n\n\n\n\n","category":"type"},{"location":"liestate.html#-1","page":"","title":"","text":"","category":"section"},{"location":"scalarfunction.html#Scalar-Functions-1","page":"Scalar Functions","title":"Scalar Functions","text":"","category":"section"},{"location":"scalarfunction.html#","page":"Scalar Functions","title":"Scalar Functions","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"scalarfunction.html#","page":"Scalar Functions","title":"Scalar Functions","text":"Instead of working with vector-valued functions like dynamics functions, we often need  to define scalar functions that accept our state and control vectors, such as cost /  objective / reward functions. This page provides the API for working with these  types of functions, represented by the abstract ScalarFunction type, which  is a specialization of an AbstractFunction with an output dimension of 1.","category":"page"},{"location":"scalarfunction.html#","page":"Scalar Functions","title":"Scalar Functions","text":"ScalarFunction","category":"page"},{"location":"scalarfunction.html#RobotDynamics.ScalarFunction","page":"Scalar Functions","title":"RobotDynamics.ScalarFunction","text":"ScalarFunction <: AbstractFunction\n\nRepresents a scalar function of the form:\n\nc = f(xu)\n\nwhere c in mathbbR.\n\nEvaluation\n\nSince the function return a scalar, both evaluate and evaluate! call the  same function methods. To avoid confusion, evaluate should always be preferred  when working with a ScalarFunction. To use, simply implement one of the following  methods:\n\nevaluate(fun, x, u, p)\nevaluate(fun, x, u)\n\nwhere p is tuple of parameters.\n\nDifferentiation\n\nFirst and second-order derivatives of scalar functions are commonly referred to as  gradients and Hessians. We use the convention that a gradient is a 1-dimensional array  (i.e. an AbstractVector with size (n,)) while the Jacobian of a scalar function is a  row vector (i.e. an AbstractMatrix with size (1,n)). Theses methods can be  called using:\n\ngradient!(::DiffMethod, fun, grad, z)\nhessian!(::DiffMethod, fun, hess, z)\n\nWhich allows the user to dispatch on the DiffMethod. These methods can  also be called by calling the more generic jacobian and ∇jacobian! methods:\n\njacobian!(sig, diff, fun, J, y, z)\n∇jacobian!(sig, diff, fun, H, b, y, z)\n\nwhere the length of y, and b is 1, and b[1] == one(eltype(b)).\n\nTo implement UserDefined methods, implement any one of the following gradient methods:\n\ngradient!(::UserDefined, fun, grad, z)\ngradient!(fun, grad, z)\ngradient!(fun, grad, x, u, p)\ngradient!(fun, grad, x, u)\n\nand any one of the following Hessian methods:\n\nhessian!(::UserDefined, fun, hess, z)\nhessian!(fun, hess, z)\nhessian!(fun, hess, x, u, p)\nhessian!(fun, hess, x, u)\n\n\n\n\n\n","category":"type"},{"location":"rotationstate.html#The-Rotation-State-1","page":"The Rotation State","title":"The Rotation State","text":"","category":"section"},{"location":"rotationstate.html#","page":"The Rotation State","title":"The Rotation State","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"rotationstate.html#","page":"The Rotation State","title":"The Rotation State","text":"As mentioned in AbstractFunction, RobotDynamics can work with non-Euclidean state vectors, or state vectors whose composition rule is not  simple addition. The most common example of non-Euclidean state vectors in robotics  is that of 3D rotations. Frequently our state vectors include a 3D rotation together  with normal Euclidean states such as position, linear or angular velocities, etc.  The RotationState StateVectorType represents this type of state vector. In general, this represents a state vector of the following form:","category":"page"},{"location":"rotationstate.html#","page":"The Rotation State","title":"The Rotation State","text":"beginbmatrix\nx_1 \nq_1 \nx_2 \nq_2 \nvdots \nx_N-1 \nq_N \nx_N\nendbmatrix","category":"page"},{"location":"rotationstate.html#","page":"The Rotation State","title":"The Rotation State","text":"where x_k in mathbbR^n_k and q_k in SO(3). Any of the n_k can be zero.","category":"page"},{"location":"rotationstate.html#","page":"The Rotation State","title":"The Rotation State","text":"This state is described by the LieState struct:","category":"page"},{"location":"rotationstate.html#","page":"The Rotation State","title":"The Rotation State","text":"LieState\nQuatState","category":"page"},{"location":"rotationstate.html#RobotDynamics.LieState","page":"The Rotation State","title":"RobotDynamics.LieState","text":"LieState{R,P}\n\nSpecifies a state with rotational components mixed in with standard vector components. All rotational components are assumed to be parameterizations of 3D rotations.\n\nParameters\n\nR <: Rotation is the rotational representation used in the state vector. Must have\n\nparams(::Type{R}) defined, which returns the number of parameters used by the rotation, as well a constructor that takes each parameter as a separate scalar argument.\n\nP <: Tuple{Vararg{Int}} is a tuple of integers specifying the partitioning of the state\n\nvector. Each element of P specifies the length of the vector component between the rotational components, and P[1] and P[end] specify the number of vector states at the beginning and end of the state vector.\n\nExamples\n\nIf we want to construct a state vector like the following: [v3, q, v2, q, v3] where v2 and v3 and vector components of length 2 and 3, respectively, and q is a 4-dimensional unit quaternion. The LieState for this state vector would be LieState{UnitQuaternion{Float64},3,2,3}. The length should be (3+4+2+4+3) = 16, which can be verified by length(s::LieState).\n\nConstructors\n\nLieState(::Type{R}, P::Tuple{Vararg{Int}})\nLieState(::Type{R}, p1::Int, p2::Int, p3::Int...)\n\n\n\n\n\n","category":"type"},{"location":"rotationstate.html#RobotDynamics.QuatState","page":"The Rotation State","title":"RobotDynamics.QuatState","text":"QuatState(n::Int, Q::StaticVector{<:Any,Int})\nQuatState(n::Int, Q::NTuple{<:Any,Int})\n\nCreate a n-dimensional LieState assuming R = UnitQuaternion{Float64} and Q[i] is the first index of each quaternion in the state vector.\n\nExample\n\nIf we want to construct a state vector like the following: [v3, q, v2, q, v3] where v2 and v3 and vector components of length 2 and 3, respectively, and q is a 4-dimensional unit quaternion. Since the first quaternion starts at index 4, and the second starts at index 10, Q = [4,10]. The entire length of the vector is n = 16 = 3 + 4 + 2 + 4 + 3, so we would call QuatState(16, SA[4,10]).\n\n\n\n\n\n","category":"function"},{"location":"rotationstate.html#The-LieGroupModel-type-1","page":"The Rotation State","title":"The LieGroupModel type","text":"","category":"section"},{"location":"rotationstate.html#","page":"The Rotation State","title":"The Rotation State","text":"To simplify the definition of models whose state vector is a RotationState, we  provide the abstract LieGroupModel type:","category":"page"},{"location":"rotationstate.html#","page":"The Rotation State","title":"The Rotation State","text":"LieGroupModel","category":"page"},{"location":"rotationstate.html#RobotDynamics.LieGroupModel","page":"The Rotation State","title":"RobotDynamics.LieGroupModel","text":"LieGroupModel <: ContinuousDynamics\n\nAbstraction of a dynamical system whose state contains at least one arbitrary rotation.\n\nUsage\n\nTo use this model, you only need to define the following functions:\n\ncontrol_dim(model::MyLieGroupModel) \nLieState(::MyLieGroupModel)\nEither dynamics! or dynamics\n\nwhere LieState(model) should return a LieState for your model,  describing how the state vector is composed of Euclidean and 3D rotations. Note that this function should only be a function of the type, not the actual  struct itself (i.e. your method definition should look like the one above).\n\n\n\n\n\n","category":"type"},{"location":"rotationstate.html#Single-rigid-bodies-1","page":"The Rotation State","title":"Single rigid bodies","text":"","category":"section"},{"location":"rotationstate.html#","page":"The Rotation State","title":"The Rotation State","text":"A lot of robotic systems, such as airplanes, quadrotors, underwater vehicles, satellites,  etc., can be described as a single rigid body subject to external forces and actuators. RobotDynamics provides the RigidBody model type for this type of system:","category":"page"},{"location":"rotationstate.html#","page":"The Rotation State","title":"The Rotation State","text":"RigidBody\nBase.position(::RBState)\norientation\nlinear_velocity\nangular_velocity\nbuild_state\nparse_state\ngen_inds\nflipquat","category":"page"},{"location":"rotationstate.html#RobotDynamics.RigidBody","page":"The Rotation State","title":"RobotDynamics.RigidBody","text":"RigidBody{R<:Rotation} <: LieGroupModel\n\nAbstraction of a dynamical system with free-body dynamics, with a 12 or 13-dimensional state vector: [p; q; v; ω] where p is the 3D position, q is the 3 or 4-dimension attitude representation, v is the 3D linear velocity, and ω is the 3D angular velocity.\n\nInterface\n\nAny single-body system can leverage the RigidBody type by inheriting from it and defining the following interface:\n\nforces(::MyRigidBody, x, u, [t])  # return the forces in the world frame\nmoments(::MyRigidBody, x, u, [t]) # return the moments in the body frame\ninertia(::MyRigidBody, x, u) # return the 3x3 inertia matrix\nmass(::MyRigidBody, x, u)  # return the mass as a real scalar\n\nInstead of defining forces and moments you can define the higher-level wrenches function\n\nwrenches(model::MyRigidbody, x, u, t)\n\nRotation Parameterization\n\nA RigidBody model must specify the rotational representation being used. Any Rotations.Rotation{3} can be used, but we suggest one of the following:\n\nUnitQuaternion\nMRP\nRodriguesParam\n\nWorking with state vectors for a RigidBody\n\nSeveral methods are provided for working with the state vectors for a RigidBody. Also see the documentation for RBState which provides a unified representation for working with states for rigid bodies, which can be easily converted to and  from the state vector representation for the given model.\n\nBase.position\norientation\nlinear_velocity\nangular_velocity\nbuild_state\nparse_state\ngen_inds\nflipquat\n\n\n\n\n\n","category":"type"},{"location":"rotationstate.html#Base.position-Tuple{RBState}","page":"The Rotation State","title":"Base.position","text":"position(x::RBState)\nposition(model::RigidBody, x::AbstractVector)\n\nReturn the 3-dimensional position of an rigid body as a SVector{3}.\n\n\n\n\n\n","category":"method"},{"location":"rotationstate.html#RobotDynamics.orientation","page":"The Rotation State","title":"RobotDynamics.orientation","text":"orientation(x::RBState)\norientation(model::RigidBody, x::AbstractVector)\n\nReturn the 3D orientation of a rigid body. Returns a Rotations.Rotation{3}.\n\n\n\n\n\n","category":"function"},{"location":"rotationstate.html#RobotDynamics.linear_velocity","page":"The Rotation State","title":"RobotDynamics.linear_velocity","text":"linear_velocity(x::RBState)\nlinear_velocity(model::RigidBody, x::AbstractVector)\n\nReturn the 3D linear velocity of a rigid body as a SVector{3}.\n\n\n\n\n\n","category":"function"},{"location":"rotationstate.html#RobotDynamics.angular_velocity","page":"The Rotation State","title":"RobotDynamics.angular_velocity","text":"angular_velocity(x::RBState)\nangular_velocity(model::RigidBody, x::AbstractVector)\n\nReturn the 3D linear velocity of a rigid body as a SVector{3}.\n\n\n\n\n\n","category":"function"},{"location":"rotationstate.html#RobotDynamics.build_state","page":"The Rotation State","title":"RobotDynamics.build_state","text":"build_state(model::RigidBody{R}, x::RBState) where R\nbuild_state(model::RigidBody{R}, x::AbstractVector) where R\nbuild_state(model::RigidBody{R}, r, q, v, ω) where R\n\nBuild the state vector for model using the RBState x. If R <: UnitQuaternion this     returns x cast as an SVector, otherwise it will convert the quaternion in x to     a rotation of type R.\n\nAlso accepts as arguments any arguments that can be passed to the constructor of RBState.\n\n\n\n\n\n","category":"function"},{"location":"rotationstate.html#RobotDynamics.parse_state","page":"The Rotation State","title":"RobotDynamics.parse_state","text":"parse_state(model::RigidBody{R}, x, renorm=false)\n\nReturn the position, orientation, linear velocity, and angular velocity as separate vectors. The orientation will be of type R. If renorm=true and R <: UnitQuaternion the quaternion will be renormalized.\n\n\n\n\n\n","category":"function"},{"location":"rotationstate.html#RobotDynamics.gen_inds","page":"The Rotation State","title":"RobotDynamics.gen_inds","text":"gen_inds(model::RigidBody)\n\nGenerate a NamedTuple containing the indices of the position (r), orientation (q), linear velocity (v), and angular velocity (ω) from the state vector for model.\n\n\n\n\n\n","category":"function"},{"location":"rotationstate.html#RobotDynamics.flipquat","page":"The Rotation State","title":"RobotDynamics.flipquat","text":"flipquat(model, x)\n\nFlips the quaternion sign for a RigidBody{<:UnitQuaternion}.\n\n\n\n\n\n","category":"function"},{"location":"rotationstate.html#The-RBState-type-1","page":"The Rotation State","title":"The RBState type","text":"","category":"section"},{"location":"rotationstate.html#","page":"The Rotation State","title":"The Rotation State","text":"When working with rigid bodies, the rotation can be represented a variety of methods and  dealing with this ambiguity can be tedious. We provide the RBState type which  represents a generic state for a rigid body, representing the orietation as a quaternion. It provides easy methods to convert to and from the state vector for a given RigidBody{R}.","category":"page"},{"location":"rotationstate.html#","page":"The Rotation State","title":"The Rotation State","text":"RBState","category":"page"},{"location":"rotationstate.html#RobotDynamics.RBState","page":"The Rotation State","title":"RobotDynamics.RBState","text":"RBState{T} <: StaticVector{13,T}\n\nRepresents the state of a rigid body in 3D space, consisting of position, orientation, linear     velocity and angular velocity, respresented as a vector stacked in that order, with     the rotation represented as the 4 elements of a unit quaternion.\n\nImplements the StaticArrays interface so can be treated as an SVector with additional     methods.\n\nConstructors\n\nRBState{T}(r, q, v, ω)\nRBState{T}(x)\nRBState(r, q, v, ω)\nRBState(x)\n\nwhere r, v, and ω are three-dimensional vectors, q is either a Rotation or a     four-dimenional vector representing the parameters of unit quaternion, and x is a     13-dimensional vector (or tuple),\n\nConverting to a State Vector\n\nAn RBState can be converted to a state vector for a RigidBody using     RBState(model::RBstate, x, [renorm=false])\n\n\n\n\n\n","category":"type"},{"location":"trajectories.html#Trajectories-1","page":"Trajectories","title":"Trajectories","text":"","category":"section"},{"location":"trajectories.html#","page":"Trajectories","title":"Trajectories","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"trajectories.html#","page":"Trajectories","title":"Trajectories","text":"When dealing with dynamical sytems, we often need to keep track of and represent  trajectories of our system. RobotDynamics provides an AbstractTrajectory that can represent any trajectory, continuous or discrete. The only requirements on an  AbstractTrajectory are that you can query the state and control at some time t, and that the trajectory has some notion of initial and final time for which it is defined. ","category":"page"},{"location":"trajectories.html#","page":"Trajectories","title":"Trajectories","text":"AbstractTrajectory","category":"page"},{"location":"trajectories.html#RobotDynamics.AbstractTrajectory","page":"Trajectories","title":"RobotDynamics.AbstractTrajectory","text":"AbstractTrajectory\n\nAn abstract representation of a state and control trajectory. \n\nRequired methods Brief description\ngetstate(Z, t) Get the state at time t.\ngetcontrol(Z, t) Get the control at time t.\ngetinitialtime(Z) Get the initial time of the trajectory.\ngetfinaltime(Z) Get the final time of the trajectory.\n\n\n\n\n\n","category":"type"},{"location":"trajectories.html#","page":"Trajectories","title":"Trajectories","text":"One convenient way of representing a trajectory is by sampling the states and controls  along it. RobotDynamics provides the SampledTrajectory type which is basically a vector  of AbstractKnotPoint types. This is described by the following API:","category":"page"},{"location":"trajectories.html#","page":"Trajectories","title":"Trajectories","text":"SampledTrajectory\nstates\ncontrols\ngettimes\ngetdata\nsetstates!\nsetcontrols!\nset_dt!\nsetinitialtime!\nnum_vars\neachcontrol","category":"page"},{"location":"trajectories.html#RobotDynamics.SampledTrajectory","page":"Trajectories","title":"RobotDynamics.SampledTrajectory","text":"SampledTrajectory{Nx,Nu,T,KP} <: AbstractTrajectory\n\nA trajectory represented by a sample of knot points. A vector of AbstractKnotPoints of type KP with state dimension Nx, control dimension Nu, and value type T.\n\nSupports iteration and indexing.\n\nConstructors\n\nSampledTrajectory{Nx,Nu}(n, m; [equal, dt, tf, N])\nSampledTrajectory{Nx,Nu}(X, U; [dt, tf, N=length(X)])\n\nSampledTrajectory(n, m; [equal, dt, tf, N])\nSampledTrajectory(X, U; [dt, tf, N=length(X)])\n\nwhere at least 2 of dt, tf, or N must be specified. The length N is automatically  inferred when passing in state and control trajectories X and U, which can either be  vectors of vectors or a 2D matrix whose 2nd dimension is time.\n\n\n\n\n\n","category":"type"},{"location":"trajectories.html#RobotDynamics.states","page":"Trajectories","title":"RobotDynamics.states","text":"states(Z)\nstates(Z, i::Integer)\nstates(Z, inds)\n\nGet a list of all the state vectors for the trajectory Z. Passing  an integer extracts a vector of the ith state. Passing a vector of  integers provides a list of N-dimensional vectors, containing the  time history for each state index in the vector.\n\n\n\n\n\n","category":"function"},{"location":"trajectories.html#RobotDynamics.controls","page":"Trajectories","title":"RobotDynamics.controls","text":"controls(Z)\ncontrols(Z, i::Integer)\ncontrols(Z, inds)\n\nGet a list of all the control vectors for the trajectory Z. Passing  an integer extracts a vector of the ith control. Passing a vector of  integers provides a list of N-dimensional vectors, containing the  time history for each control index in the vector.\n\n\n\n\n\n","category":"function"},{"location":"trajectories.html#RobotDynamics.gettimes","page":"Trajectories","title":"RobotDynamics.gettimes","text":"gettimes(Z)\n\nGet a vector of times for the entire trajectory.\n\n\n\n\n\n","category":"function"},{"location":"trajectories.html#RobotDynamics.getdata","page":"Trajectories","title":"RobotDynamics.getdata","text":"getdata(Z)\n\nGet a list of the concatenated state and control vectors.\n\n\n\n\n\n","category":"function"},{"location":"trajectories.html#RobotDynamics.setstates!","page":"Trajectories","title":"RobotDynamics.setstates!","text":"setstates!(Z, X)\n\nSet the states of a trajectory Z, where X can be a vector of vectors or a matrix of size (n,N).\n\n\n\n\n\n","category":"function"},{"location":"trajectories.html#RobotDynamics.setcontrols!","page":"Trajectories","title":"RobotDynamics.setcontrols!","text":"setcontrols!(Z, U)\n\nSet the controls of a trajectory Z, where U can be a vector of vectors or a matrix of size (m,N) or a single vector of size (m,), which will be copied to all the  time steps.\n\n\n\n\n\n","category":"function"},{"location":"trajectories.html#RobotDynamics.set_dt!","page":"Trajectories","title":"RobotDynamics.set_dt!","text":"set_dt!(Z, dt)\n\nSet a constant time step for the entire trajectory.\n\n\n\n\n\n","category":"function"},{"location":"trajectories.html#RobotDynamics.setinitialtime!","page":"Trajectories","title":"RobotDynamics.setinitialtime!","text":"setinitialtime!(Z, t0)\n\nSet the initial time of the trajectory, shifting all of the times by the required amount.\n\n\n\n\n\n","category":"function"},{"location":"trajectories.html#RobotDynamics.num_vars","page":"Trajectories","title":"RobotDynamics.num_vars","text":"num_vars(Z)\n\nTotal number of states and controls in a trajectory Z.\n\n\n\n\n\n","category":"function"},{"location":"trajectories.html#RobotDynamics.eachcontrol","page":"Trajectories","title":"RobotDynamics.eachcontrol","text":"eachcontrol(Z)\n\nGet the range of indices for valid controls.\n\n\n\n\n\n","category":"function"},{"location":"discrete.html#Discrete-Dynamics-1","page":"Discrete Dynamics","title":"Discrete Dynamics","text":"","category":"section"},{"location":"discrete.html#","page":"Discrete Dynamics","title":"Discrete Dynamics","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"discrete.html#","page":"Discrete Dynamics","title":"Discrete Dynamics","text":"This page provides the API for discrete dynamics models.","category":"page"},{"location":"discrete.html#","page":"Discrete Dynamics","title":"Discrete Dynamics","text":"Pages = [\"discrete.md\"]\nDepth = 3","category":"page"},{"location":"discrete.html#Discrete-Dynamics-type-1","page":"Discrete Dynamics","title":"Discrete Dynamics type","text":"","category":"section"},{"location":"discrete.html#","page":"Discrete Dynamics","title":"Discrete Dynamics","text":"DiscreteDynamics","category":"page"},{"location":"discrete.html#RobotDynamics.DiscreteDynamics","page":"Discrete Dynamics","title":"RobotDynamics.DiscreteDynamics","text":"DiscreteDynamics\n\nA dynamics model of the form\n\nx_k+1 = f(x_k u_k)\n\nwhere x is the n-dimensional state vector and u is the m-dimensional control vector. The following methods should be defined on any model:\n\nstate_dim(model)\ncontrol_dim(model)\n\nThe output dimension output_dim is automatically defined to be equal to the  state dimension. \n\nDefining the dynamics\n\nTo define the dynamics using out-of-place (returning an SVector) evaluation,  the user must define one of the following:\n\ndiscrete_dynamics(model, z::AbstractKnotPoint)\ndiscrete_dynamics(model, x, u, t, dt)\n\nwhere t is the current time and dt is the time step between x_k and x_k+1.\n\nThe user shouldn't assume that the inputs are static arrays, although for best  computational performance these methods should be called by passing in static arrays.\n\nTo define the dynamics using in-place evaluation, the user must define one of the following:\n\ndiscrete_dynamics!(model, xn, z::AbstractKnotPoint)\ndiscrete_dynamics!(model, xn, x, u, t, dt)\n\nEither of these function can be called by dispatching on the FunctionSignature using:\n\ndiscrete_dynamics!(sig, model, xn, z::AbstractKnotPoint)\n\nDiscretizing continuous dynamics\n\nThis type is the abstract type representing all discrete dynamics systems, whether  or not they are approximations of continuous systems. Users can choose to implement  their dynamics directly in discrete time using this interface, or can use  DiscretizedDynamics to discretize a continuous time system.\n\nImplicit dynamics functions\n\nSometimes continuous time systems are approximated using implicit integrators of the  form \n\nd(x_k+1 u_k+1 x_k u_k) = 0\n\nTo evaluate these types of systems, use the dynamics_error and  dynamics_error! methods, which will return the output of f for  two consecutive knot points. The default functions such as discrete_dynamics or jacobian! are not defined for these types of systems.\n\nSimulating the dynamics\n\nUse propagate_dynamics! to conveniently save the next state directly into  the state vector of another KnotPoint.\n\n\n\n\n\n","category":"type"},{"location":"discrete.html#Methods-for-Discrete-Dynamics-models-1","page":"Discrete Dynamics","title":"Methods for Discrete Dynamics models","text":"","category":"section"},{"location":"discrete.html#","page":"Discrete Dynamics","title":"Discrete Dynamics","text":"discrete_dynamics\ndiscrete_dynamics!\ndynamics_error\ndynamics_error!\ndynamics_error_jacobian!\npropagate_dynamics!","category":"page"},{"location":"discrete.html#RobotDynamics.discrete_dynamics","page":"Discrete Dynamics","title":"RobotDynamics.discrete_dynamics","text":"discrete_dynamics(model, z::AbstractKnotPoint)\ndiscrete_dynamics(model, x, u, t, dt)\n\nEvaluate the discrete time dynamics, returning the output x_k+1. For best  performance, the output should be a StaticArrays.SVector. This method is called  when using the StaticReturn FunctionSignature.\n\nCalling evaluate on a DiscreteDynamics model will call this function.\n\n\n\n\n\n","category":"function"},{"location":"discrete.html#RobotDynamics.discrete_dynamics!","page":"Discrete Dynamics","title":"RobotDynamics.discrete_dynamics!","text":"discrete_dynamics!(model, xn, z::AbstractKnotPoint)\ndiscrete_dynamics!(model, xn, x, u, t, dt)\n\nEvaluate the discrete time dynamics, storing the output in xn.  This method is called when using the InPlace FunctionSignature.\n\nCalling evaluate! on a DiscreteDynamics model will call this function.\n\n\n\n\n\ndiscrete_dynamics!(sig, xn, z::AbstractKnotPoint)\n\nEvaluate the discrete dynamics function, storing the output in xn, using the  FunctionSignature sig to determine which method to call.\n\n\n\n\n\n","category":"function"},{"location":"discrete.html#RobotDynamics.dynamics_error","page":"Discrete Dynamics","title":"RobotDynamics.dynamics_error","text":"dynamics_error(model, z2, z1)\n\nEvaluate the dynamics error between two knot points for a DiscreteDynamics  model. In general, this function takes the form:\n\nd(x_k+1 u_k+1 x_k u_k) = 0\n\nFor explicit integration methods of the form x_k+1 = f(x_k u_k), this is just\n\nd(x_k u_k) - x_k+1 = 0\n\nThis is the method that should be used with implicit integration methods.\n\nThis form is the out-of-place form that should, in general, return a  StaticVectors.SVector. See dynamics_error! for the in-place method.\n\nThe Jacobian of this function is evaluated by calling dynamics_error_jacobian!.\n\n\n\n\n\n","category":"function"},{"location":"discrete.html#RobotDynamics.dynamics_error!","page":"Discrete Dynamics","title":"RobotDynamics.dynamics_error!","text":"dynamics_error!(model, y2, y1, z2, z1)\n\nEvaluate the dynamics error between two knot points for a DiscreteDynamics model. The output is stored in y2, and y1 is provided as a extra input that can be used  to store temporary results. Any specific usage of this variable is left to the user.\n\nSee dynamics_error for more details on this function.\n\n\n\n\n\n","category":"function"},{"location":"discrete.html#RobotDynamics.dynamics_error_jacobian!","page":"Discrete Dynamics","title":"RobotDynamics.dynamics_error_jacobian!","text":"dynamics_error_jacobian!(sig, diff, model, J2, J1, y2, y1, z2, z1)\n\nEvaluate the Jacobian of dynamics_error. The derivative with respect to  the first knotpoint z1 should be stored in J1, and the derivative with respect to  the second knotpoint z2 should be stored in J2. The variables y2 and y1 should be  vectors of the size of the output dimension (usually the state dimension) and are provided  as extra cache variables whose usage is left to be determined by the user. For example,  a user could choose to evaluate the dynamics error and store the result in one of these  variables to evaluate the error and it's Jacobian at the same time.\n\nBoth J2 and J1 must have dimensions (p, n + m) where n, m, and p are the output  of state_dim, control_dim, and output_dim. Usually p = n.\n\nNote that for explicit integration methods of the form x_{k+1} = f(x_k, u_k) J2 should  be equal to [-I(n) zeros(n,m)].\n\nImplementing on a custom type\n\nTo implement this function on a new DiscreteDynamics model, define methods  for the FunctionSignature and DiffMethod of your choice. These are  automatically defined when using @autodiff on a DiscreteDynamics model. To implement the UserDefined DiffMethod, implement the following method:\n\ndynamics_error_jacobian!(model, J2, J1, y2, y1, \n                         z2::AbstractKnotPoint, z1::AbstractKnotPoint)\n\n\n\n\n\n","category":"function"},{"location":"discrete.html#RobotDynamics.propagate_dynamics!","page":"Discrete Dynamics","title":"RobotDynamics.propagate_dynamics!","text":"propagate_dynamics!(sig, model, z2, z1)\n\nSave the output of either discrete_dynamics or discrete_dynamics! evaluated using z1 into the state vector of z2. Useful for simulating discrete systems  forward in time.\n\n\n\n\n\n","category":"function"},{"location":"discrete.html#Discretizing-Continuous-Models-1","page":"Discrete Dynamics","title":"Discretizing Continuous Models","text":"","category":"section"},{"location":"discrete.html#","page":"Discrete Dynamics","title":"Discrete Dynamics","text":"DiscretizedDynamics\nQuadratureRule\nExplicit\nImplicit","category":"page"},{"location":"discrete.html#RobotDynamics.DiscretizedDynamics","page":"Discrete Dynamics","title":"RobotDynamics.DiscretizedDynamics","text":"DiscretizedDynamics\n\nRepresents a DiscreteDynamics model formed by integrating a continuous  dynamics model. It is essentially a ContinuousDynamics paired with a  QuadratureRule that defines how to use the dynamics! function  to get a discrete_dynamics! function. \n\nConstructor\n\nA DiscretedDynamics type can be created using either of the following signatures:\n\nDiscretizedDynamics(dynamics::ContinuousDynamics, Q::QuadratureRule)\nDiscretizedDynamics{Q}(dynamics::ContinuousDynamics) where Q <: QuadratureRule\n\nIn the second case, the integrator is constructed by calling  Q(state_dim(dynamics), control_dim(dynamics)).\n\nUsage\n\nA DiscretizedDynamics model is used just like any other DiscreteDynamics model. The state, control, and error state dimensions are all taken from the  continuous time dynamics model, and the StateVectorType and  FunctionInputs traits are inherited from the continuous time dynamics.\n\nThe default_diffmethod, however, is set to ForwardAD, since our benchmarks show that  it is usually faster to make a single call to ForwardDiff.jacobian! than using the chain  rule and multiple calls to query the Jacobian of the continuous dynamics at multiple points. If the continuous model has a UserDefined Jacobian method, calling jacobian! on  a DiscretizedDynamics model will use the chain rule with analytical Jacobians of  the integrator. If the user wants to use a combination of ForwardDiff (or any other  differentiation method, for that matter) with the integrator, they are free to define their  own DiffMethod to dispatch on.\n\n\n\n\n\n","category":"type"},{"location":"discrete.html#RobotDynamics.QuadratureRule","page":"Discrete Dynamics","title":"RobotDynamics.QuadratureRule","text":"QuadratureRule\n\nIntegration rule for approximating the continuous integrals for the equations of motion. Currently divided into two classes of integrators:\n\nExplicit\nImplicit\n\nInterface\n\nAll integrators need to have a constructor of the form:\n\nQ(n, m)\n\nwhere n and m are the state and control dimensions of the dynamical system.\n\n\n\n\n\n","category":"type"},{"location":"discrete.html#RobotDynamics.Explicit","page":"Discrete Dynamics","title":"RobotDynamics.Explicit","text":"Explicit <: QuadratureRule\n\nIntegration rules of the form \n\nx_k+1 = f(x_ku_k)\n\n.\n\nInterface\n\nAll explicit integrators need to define the following methods:\n\nintegrate(::Q, model, x, u, t, h)\nintegrate!(::Q, model, xn, x, u, t, h)\njacobian!(::Q, sig, model, J, xn, x, u, t, h)\n\nwhere h is the time step (i.e. dt). The Jacobian J should have size (n, n + m). The sig is a FunctionSignature that can be used to dispatch the Jacobian on  the desired function signature. For example, when using StaticReturn intermediate  cache variables aren't usually needed, but are when using InPlace methods. These cache variables can be stored in the integrator itself (see the ADVector type provided by this package).\n\nnote: Note\nThe Q in these methods should be replaced by your explicit integrator,  e.g. MyRungeKutta.\n\n\n\n\n\n","category":"type"},{"location":"discrete.html#RobotDynamics.Implicit","page":"Discrete Dynamics","title":"RobotDynamics.Implicit","text":"Implicit <: QuadratureRule\n\nIntegration rules of the form \n\nf(x_k+1u_k+1x_ku_k) = 0\n\n.\n\nInterface\n\nAll implicit integrators need to define the following methods:\n\ndynamics_error(::Q, model, z2, z1)\ndynamics_error!(::Q, model, y2, y1, z2, z1)\ndynamics_error_jacobian!(::Q, sig, model, J2, J1, y2, y1, z2, z1)\n\nwhere model is a ContinuousDynamics model. For the in place method,  the output should be stored in the y2 vector. For the Jacobian method, J2  holds the Jacobian with respect to the state and control of z2 (the knot point  at the next time step) and J1 holds the Jacobian with respect to the state  and control of z1 (the knot point at the current time step).\n\n\n\n\n\n","category":"type"},{"location":"discrete.html#Implemented-Integrators-1","page":"Discrete Dynamics","title":"Implemented Integrators","text":"","category":"section"},{"location":"discrete.html#Explicit-1","page":"Discrete Dynamics","title":"Explicit","text":"","category":"section"},{"location":"discrete.html#","page":"Discrete Dynamics","title":"Discrete Dynamics","text":"Euler\nRK3\nRK4","category":"page"},{"location":"discrete.html#RobotDynamics.Euler","page":"Discrete Dynamics","title":"RobotDynamics.Euler","text":"Euler\n\nExplicit Euler integration:\n\nx_k+1 = x_k + h f(x_k u_k)\n\nwhere h is the time step.\n\nwarning: Warning\nIn general, explicit Euler integration SHOULD NOT BE USED! It is the worst possible  integration method since it is very inaccurate and can easily go unstable.\n\n\n\n\n\n","category":"type"},{"location":"discrete.html#RobotDynamics.RK3","page":"Discrete Dynamics","title":"RobotDynamics.RK3","text":"RK3\n\nA third-order explicit Runge-Kutta method:\n\nbeginaligned\nk_1 = f(x_k u_k t) h \nk_2 = f(x_k + frac12 k_1 u_k t + frac12 h) h \nk_3 = f(x_k - k_1 + 2 k_2 u_k t + h) h \nx_k+1 = x_k + frac16 (k_1 + 4 k_2 + k_3) \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"discrete.html#RobotDynamics.RK4","page":"Discrete Dynamics","title":"RobotDynamics.RK4","text":"RK4\n\nThe classic fourth-order explicit Runge-Kutta method.\n\nbeginaligned\n k_1 = f(x_k u_k t) h \n k_2 = f(x_k + frac12 k_1 u_k t + frac12 h) h \n k_3 = f(x_k + frac12 k_2 u_k t + frac12 h) h \n k_4 = f(x_k +  k_3 u_k t + h) h \n x_k+1 = x_k + frac16(k_1 + 2k_2 + 2k_3 + k_4)\nendaligned\n\n\n\n\n\n","category":"type"},{"location":"discrete.html#Implicit-1","page":"Discrete Dynamics","title":"Implicit","text":"","category":"section"},{"location":"discrete.html#","page":"Discrete Dynamics","title":"Discrete Dynamics","text":"ImplicitMidpoint","category":"page"},{"location":"discrete.html#RobotDynamics.ImplicitMidpoint","page":"Discrete Dynamics","title":"RobotDynamics.ImplicitMidpoint","text":"ImplicitMidpoint\n\nA symplectic method with second-order accuracy. A great option for those wanting  good performance with few calls to the dynamics.\n\nmath x_1 + h f(\\frac{1}{2}(x_1 + x_2), u_1, t + \\frac{1}{2} h) - x_2 = 0`\n\n\n\n\n\n","category":"type"},{"location":"discrete.html#Interal-API-1","page":"Discrete Dynamics","title":"Interal API","text":"","category":"section"},{"location":"discrete.html#","page":"Discrete Dynamics","title":"Discrete Dynamics","text":"ADVector","category":"page"},{"location":"discrete.html#RobotDynamics.ADVector","page":"Discrete Dynamics","title":"RobotDynamics.ADVector","text":"ADVector{T}\n\nA cache of vectors for making it easier to ForwardDiff. A vector of the desired type      is extracted by indexing:\n\nvec = adv[eltype(x)]\n\nSince ForwardDiff Duals are parameterized on the chunk size, this type will store any  number of vectors for different chunk sizes. A new vector of duals will be automatically created (once) if it doesn't exist yet.\n\nFor best performance (by avoiding type-instability), annotate the indexing operation:\n\nvec = adv[T]::Vector{T}\n\nWhile the annotation could have been included in the indexing operation itself, some  benchmark results found it significantly faster to apply the annotation at the call site.\n\nConstructor\n\nADVector{T}(n)\n\nwhere n is the size of the vectors, and T is the numeric type (typically Float64).\n\n\n\n\n\n","category":"type"},{"location":"continuous.html#Continuous-Dynamics-1","page":"Continuous Dynamics","title":"Continuous Dynamics","text":"","category":"section"},{"location":"continuous.html#","page":"Continuous Dynamics","title":"Continuous Dynamics","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"continuous.html#","page":"Continuous Dynamics","title":"Continuous Dynamics","text":"This page provides the API for continuous dynamics models.","category":"page"},{"location":"continuous.html#","page":"Continuous Dynamics","title":"Continuous Dynamics","text":"Pages = [\"continuous.md\"]\nDepth = 3","category":"page"},{"location":"continuous.html#Continuous-Dynamics-type-1","page":"Continuous Dynamics","title":"Continuous Dynamics type","text":"","category":"section"},{"location":"continuous.html#","page":"Continuous Dynamics","title":"Continuous Dynamics","text":"ContinuousDynamics","category":"page"},{"location":"continuous.html#RobotDynamics.ContinuousDynamics","page":"Continuous Dynamics","title":"RobotDynamics.ContinuousDynamics","text":"ContinuousDynamics\n\nA dynamics model of the form:\n\ndotx = f(xu)\n\nwhere x is the n-dimensional state vector and u is the m-dimensional control vector. The following methods should be defined on any model:\n\nstate_dim(model)\ncontrol_dim(model)\n\nThe output dimension output_dim is automatically defined to be equal to the  state dimension. \n\nDefining the dynamics\n\nTo define the dynamics using out-of-place (returning an SVector) evaluation,  the user must define one of the following:\n\ndynamics(model, z::AbstractKnotPoint)\ndynamics(model, x, u, t)\ndynamics(model, x, u)\n\nThe user shouldn't assume that the inputs are static arrays, although for best  computational performance these methods should be called by passing in static arrays.\n\nTo define the dynamics using in-place evaluation, the user must define one of the following:\n\ndynamics!(model, xdot, z::AbstractKnotPoint)\ndynamics!(model, xdot, x, u, t) \ndynamics!(model, xdot, x, u)\n\nA user-defined Jacobian can be provided by defining one of the following methods\n\njacobian!(model, J, xdot, z::AbstractKnotPoint)\njacobian!(model, J, xdot, x, u, t)\njacobian!(model, J, xdot, x, u)\n\nNon-Euclidean state vectors\n\nBy default, all elements of the state vector are assume to be in Euclidean space. This assumption can be relaxed by defining a few extra functions. For non-Euclidean  state vectors, the Euclidean difference between two states, or the error state, is no  longer computed using pure subtraction. We can define a custom function for taking the  differences between 2 states vectors based on the type of the state vector. \n\nWe can query the type of the state vector using statevectortype(model),  which returns a StateVectorType trait (by default, EuclideanState). After defining a new StateVectorType and the following methods (described in more  detail in the documentation for StateVectorType):\n\nstate_diff!\nerrstate_dim\nstate_diff_jacobian!\n∇state_diff_jacobian!\n\nWe can use dynamics with non-Euclidean state vectors. The most commonly encounter  case of this is when using 3D rotations. Support for states with 3D rotations is  provided by the RotationState StateVectorType.\n\n\n\n\n\n","category":"type"},{"location":"continuous.html#Methods-on-continuous-dynamics-types-1","page":"Continuous Dynamics","title":"Methods on continuous dynamics types","text":"","category":"section"},{"location":"continuous.html#","page":"Continuous Dynamics","title":"Continuous Dynamics","text":"dynamics\ndynamics!","category":"page"},{"location":"continuous.html#RobotDynamics.dynamics","page":"Continuous Dynamics","title":"RobotDynamics.dynamics","text":"dynamics(model, z::AbstractKnotPoint)\ndynamics(model, x, u, t)\ndynamics(model, x, u)\n\nEvaluate the continuous time dynamics, returning the output dotx. For best  performance, the output should usually be a StaticArrays.SVector. This method is  called when using the StaticReturn FunctionSignature.\n\nCalling evaluate on a ContinuousDynamics model will call this function.\n\n\n\n\n\n","category":"function"},{"location":"continuous.html#RobotDynamics.dynamics!","page":"Continuous Dynamics","title":"RobotDynamics.dynamics!","text":"dynamics!(model, xdot, z::AbstractKnotPoint)\ndynamics!(model, xdot, x, u, t)\ndynamics!(model, xdot, x, u)\n\nEvaluate the continuous time dynamics, storing the output in xdot.  This method is called when using the InPlace FunctionSignature.\n\nCalling evaluate! on a ContinuousDynamics model will call this function.\n\n\n\n\n\ndynamics!(sig, model, xdot, z::AbstractKnotPoint)\n\nEvaluate the continuous time dynamics, storing the output in xdot, using the  FunctionSignature sig to determine which method to call.\n\n\n\n\n\n","category":"function"},{"location":"index.html#RobotDynamics.jl-1","page":"Introduction","title":"RobotDynamics.jl","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Welcome to RobotDynamics.jl! This package is dedicated to providing a convenient interface for defining the dynamics of forced dynamical systems, such as robots.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"This package also provides many efficient methods for evaluating dynamics, their Jacobians, and their discrete-time versions for use in optimization packages such as TrajectoryOptimization.jl.","category":"page"},{"location":"index.html#Getting-Started-1","page":"Introduction","title":"Getting Started","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"a = 1\nb = 2\na + b","category":"page"},{"location":"index.html#Defining-a-new-continuous-dynamics-model-1","page":"Introduction","title":"Defining a new continuous dynamics model","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"It is pretty straightforward to define a new dynamics model. We start by creating  new struct that inherits from ContinuousDynamics. You can store any model parameters in the model struct:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using RobotDynamics\nstruct MyModel <: RobotDynamics.ContinuousDynamics\n    mass::Float64\n    spring_stiffness::Float64\nend","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"We now need to specify the dimensions of our state and control vectors:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"RobotDynamics.state_dim(::MyModel) = 2\nRobotDynamics.control_dim(::MyModel) = 1","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"tip: Tip\nFor best performance, these output of these functions should be static  with respect to the model type. For example, storing the state and control dimension as variables in the model and returning them can degrade   performance.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Now we're ready to define our dynamics functions. We can specify either in-place  or out-of-place dynamics functions signatures. We start with the in-place  definition:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"function RobotDynamics.dynamics!(model::MyModel, xdot, x, u)\n    # x is the state vector\n    # u is the control vector\n    p = x[1]  # position \n    v = x[2]  # velocity\n    pdot = v\n    F = -model.spring_stiffness * p + u[1]  # force\n    vdot = F / model.mass\n    xdot[1] = pdot\n    xdot[2] = vdot\n    nothing\nend","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"warning: Warning\nBe sure to exactly match this function signature. Following standard Julia conventions, the in-place version uses a !, while the out-of-place method  below does not.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"For small systems like this, it is often efficient to use out-of-place methods  with StaticArrays. Our signature looks almost identical, except that it does not have a ! at the end, and does  not have xdot as a argument:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using StaticArrays\nfunction RobotDynamics.dynamics(model::MyModel, x, u)\n    p = x[1]  # position \n    v = x[2]  # velocity\n    pdot = v\n    F = -model.spring_stiffness * p + u[1]  # force\n    vdot = F / model.mass\n    return SA[pdot, vdot]  # shortcut to create an SVector\nend","category":"page"},{"location":"index.html#Calling-the-dynamics-1","page":"Introduction","title":"Calling the dynamics","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Now that we've defined our dynamics, let's see how we can call it. This package  provides the KnotPoint type that stores the state and control vector  together with information about the time. Let's start by creating our model  and some KnotPoint types:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"mass = 1.0\nstiffness = 0.5\nmodel = MyModel(mass, stiffness)\nn = RobotDynamics.state_dim(model)\nm = RobotDynamics.control_dim(model)\n\n# Create a KnotPoint using SVectors \n# (should use this when calling out-of-place methods)\nxs = @SVector randn(n)\nus = @SVector randn(m)\nt = 0.0   # current time\ndt = NaN  # time step, not needed for continuous models\nzs = KnotPoint(xs, us, t, dt)\n\n# Create a KnotPoint using normal vectors\n# (using 's' for static, 'd' for dynamic)\nxd = Vector(xs)\nud = Vector(us)\nzd = KnotPoint{n,m}(xd, ud, t, dt)","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Now that we've defined some inputs, let's evaluate our continuous dynamics. We  can use any of the methods below:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"# Out-of-place methods\nRobotDynamics.dynamics(model, zs)\nRobotDynamics.dynamics(model, xs, us)\nRobotDynamics.dynamics(model, xs, us, t)\n\n# In-place methods\nxdot = zeros(n)\nRobotDynamics.dynamics!(model, xdot, zd)\nRobotDynamics.dynamics!(model, xdot, xd, ud)\nRobotDynamics.dynamics!(model, xdot, xd, ud, t)\nxd","category":"page"},{"location":"index.html#Querying-the-dynamics-Jacobian-1","page":"Introduction","title":"Querying the dynamics Jacobian","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Writing down an analytical dynamics Jacobian can often be time-consuming and  error-prone. RobotDynamics allows the user to specify, at run time, the method  to be used to evaluate the dynamics Jacobians, as long as they are defined on  your type. To automatically define methods that use  ForwardDiff.jl or FiniteDiff.jl, you can use the @autodiff macro provided by this package. This modifies your model, adding new fields for the caches used by these methods, as well as the  methods to evaluate them. For our example, all we have to do is add the macro  before our model struct definition:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using RobotDynamics     # hide\nusing StaticArrays      # hide\n# NOTE: must include these packages when using `@autodiff`\nusing ForwardDiff\nusing FiniteDiff\nRobotDynamics.@autodiff struct MyModel <: RobotDynamics.ContinuousDynamics\n    mass::Float64\n    spring_stiffness::Float64\nend\nRobotDynamics.state_dim(::MyModel) = 2    # hide\nRobotDynamics.control_dim(::MyModel) = 1  # hide\n\nfunction RobotDynamics.dynamics!(model::MyModel, xdot, x, u)  # hide\n    # x is the state vector                                   # hide\n    # u is the control vector                                 # hide\n    p = x[1]                                                  # hide\n    v = x[2]                                                  # hide\n    pdot = v                                                  # hide\n    F = -model.spring_stiffness * p + u[1]                    # hide\n    vdot = F / model.mass                                     # hide\n    xdot[1] = pdot                                            # hide\n    xdot[2] = vdot                                            # hide\n    nothing                                                   # hide\nend                                                           # hide\n\nfunction RobotDynamics.dynamics(model::MyModel, x, u)         # hide\n    p = x[1]                                                  # hide\n    v = x[2]                                                  # hide\n    pdot = v                                                  # hide\n    F = -model.spring_stiffness * p + u[1]                    # hide\n    vdot = F / model.mass                                     # hide\n    return SA[pdot, vdot]                                     # hide\nend                                                           # hide","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"warning: Warning\nAdding the @autodiff method before a type will require you to restart any  active Julia kernels you have running, since it changes the type definition by adding a type parameter and a couple extra fields related to the  caches for ForwardDiff and FiniteDiff. ","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"After which we can use the following generic methods to evaluate our dynamics Jacobians:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"mass = 1.0                          # hide\nstiffness = 0.5                     # hide\nmodel = MyModel(mass, stiffness)    # hide\nn, m = RobotDynamics.dims(model)    # hide\nxs = @SVector randn(n)              # hide\nus = @SVector randn(m)              # hide\nt = 0.0                             # hide\nh = 0.1                             # hide\nzs = KnotPoint(xs, us, t, h)        # hide\nxd = Vector(xs)                     # hide\nud = Vector(us)                     # hide\nzd = KnotPoint{n,m}(xd, ud, t, h)   # hide\nxdot = zeros(n)                     # hide\n\nJ = zeros(n, n + m)\nsig = RobotDynamics.StaticReturn()  # out-of-place signature\ndiff = RobotDynamics.ForwardAD()    # use forward AD differentiation\nRobotDynamics.jacobian!(sig, diff, model, J, xdot, zs)\n\nsig = RobotDynamics.InPlace()            # out-of-place signature\ndiff = RobotDynamics.FiniteDifference()  # use finite differences \nRobotDynamics.jacobian!(sig, diff, model, J, xdot, zd)","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"These methods should always be called using a KnotPoint input, since it's more efficient to differentiation the dynamics treating the state and control as a  single vector input into the dynamics, which is why the KnotPoint type stores them as a concatenated vector.","category":"page"},{"location":"index.html#Discretizing-our-dynamics-1","page":"Introduction","title":"Discretizing our dynamics","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"We often need to discretize our continuous dynamics, either to simulate it or  feed it into optimization frameworks. The DiscretizedDynamics type  discretizes a ContinuousDynamics model, turning it into a  DiscreteDynamics model by applying a QuadratureRule. To discretize our system using, e.g. Runge-Kutta 4, we create a new  DiscretizedDynamics model:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"rk4 = RobotDynamics.RK4(n, m)  # create the integrator\nmodel_discrete = RobotDynamics.DiscretizedDynamics(model, rk4)","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"We can query our discrete dynamics using very similar methods to those we  used before, except now we have to specify the time step.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"# Specify a time step of 0.1 seconds\nzs.dt = 0.1\nzd.dt = 0.1\n\n# Out-of-place methods\nRobotDynamics.discrete_dynamics(model_discrete, zs)\nRobotDynamics.discrete_dynamics(model_discrete, xs, us, t, dt)\n\n# In-place methods\nxn = zeros(n)\nRobotDynamics.discrete_dynamics!(model_discrete, xn, zd)\nRobotDynamics.discrete_dynamics!(model_discrete, xn, xd, ud, t, dt)","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"The Jacobians are called using the same methods used for the continuous dynamics.","category":"page"},{"location":"autodiff.html#Differentiation-API-1","page":"Differentiation API","title":"Differentiation API","text":"","category":"section"},{"location":"autodiff.html#","page":"Differentiation API","title":"Differentiation API","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"autodiff.html#","page":"Differentiation API","title":"Differentiation API","text":"RobotDynamics allows users to define different methods for obtaining derivatives of their  functions. This is accomplished via the DiffMethod trait, which by default  has three options:","category":"page"},{"location":"autodiff.html#","page":"Differentiation API","title":"Differentiation API","text":"ForwardAD: forward-mode automatic differentiation using   ForwardDiff.jl\nFiniteDifference: finite difference approximation using   FiniteDiff.jl\nUserDefined: analytical function defined by the user.","category":"page"},{"location":"autodiff.html#","page":"Differentiation API","title":"Differentiation API","text":"Almost every Jacobian is queried using the same form:","category":"page"},{"location":"autodiff.html#","page":"Differentiation API","title":"Differentiation API","text":"jacobian!(sig, diff, fun, J, y, z)","category":"page"},{"location":"autodiff.html#","page":"Differentiation API","title":"Differentiation API","text":"where sig is a FunctionSignature, diff is a DiffMethod, fun is  an AbstractFunction, J is the Jacobian, y is a vector the size of the  output of the function, and z is an [AbstractKnotPoint]. Users are free to add more  DiffMethod types to dispatch on their own differentiation method. ","category":"page"},{"location":"autodiff.html#","page":"Differentiation API","title":"Differentiation API","text":"By default, no differentiation methods are provided for an AbstractFunction,  allowing the user to choose what methods they want defined, and to allow customization  of the particular method to their function. However, we do provide the following macro  to provide efficient implementations for ForwardAD and FiniteDifference:","category":"page"},{"location":"autodiff.html#","page":"Differentiation API","title":"Differentiation API","text":"@autodiff","category":"page"},{"location":"autodiff.html#RobotDynamics.@autodiff","page":"Differentiation API","title":"RobotDynamics.@autodiff","text":"@autodef struct_def\n\nSets up methods to automatically evaluate the Jacobian of the function. By default, it defines these methods for a new type NewFun:\n\njacobian!(::InPlace, ::ForwardAD, fun::NewFun, J, y, z)\njacobian!(::InPlace, ::FiniteDifference, fun::NewFun, J, y, z)\njacobian!(::StaticReturn, ::ForwardAD, fun::NewFun, J, y, z)\njacobian!(::StaticReturn, ::FiniteDifference, fun::NewFun, J, y, z)\n\nThese methods are all optimized to be non-allocating.\n\nThe method will modify the type definition, adding fields and type parameters to set them  up for efficient evaluation of the jacobians. The changes are usually transparent to the user.\n\nIf an inner constructor is provided, the signature will be unchanged, but will be modified to initialize the new fields and provide the new type parameters.\n\nLimitations\n\nRobotDynamics must be defined the local module (cannot be hidden by an alias)\nForwardDiff and FiniteDiff must both be defined in the local module, since the  struct is modified to include caches from these modules.\nIf the type has type parameters and no inner constructor, the type parameters must be  explicitly provided when constructing the object. No automatic inference will be done. It's best to explicitly provide an inner constructor with the desired behavior.\n\nExamples\n\nusing RobotDynamics, ForwardDiff, FiniteDiff\nconst RD = RobotDynamics\nRD.@autodiff struct MyFun <: RD.AbstractFunction end\n\nwill define\n\nstruct MyFun{CH} <: RobotDynamics.AbstractFunction\n    cfg::ForwardDiff.JacobianConfig{Nothing, Float64, CH, Tuple{Vector{ForwardDiff.Dual{Nothing, Float64, CH}}, Vector{(ForwardDiff).Dual{Nothing, Float64, CH}}}}\n    cache::FiniteDiff.JacobianCache{Vector{Float64}, Vector{Float64}, Vector{Float64}, UnitRange{Int64}, Nothing, Val{:forward}(), Float64}\n    function MyFun()\n        model = new{0}()\n        _n = input_dim(model)\n        _m = output_dim(model)\n        cfg = ForwardDiff.JacobianConfig(nothing, zeros(Float64, _m), zeros(Float64, _n))\n        model = new{length(cfg).seeds}(cfg)\n        _n = input_dim(model)\n        _m = output_dim(model)\n        cache = FiniteDiff.JacobianCache(zeros(Float64, _n), zeros(Float64, _m))\n        model = new{length(cfg).seeds}(cfg, cache)\n    end\nend\n\nfunction RobotDynamics.jacobian!(::InPlace, ::ForwardAD, fun::MyFun, J, y, z)\n    f_aug!(y, z_) = begin\n        RobotDynamics.evaluate!(fun, y, RobotDynamics.setinputs!(z, z_))\n        ForwardDiff.jacobian!(J, f_aug!, y, z, fun.cfg)\n    end\nend\n...  # other Jacobian methods\n\n\n\n\n\n","category":"macro"},{"location":"functionbase.html#AbstractFunction-1","page":"AbstractFunction API","title":"AbstractFunction API","text":"","category":"section"},{"location":"functionbase.html#","page":"AbstractFunction API","title":"AbstractFunction API","text":"CurrentModule = RobotDynamics","category":"page"},{"location":"functionbase.html#","page":"AbstractFunction API","title":"AbstractFunction API","text":"RobotDynamics sets up a unified framework for evaluating functions accepting a  state and control vector as inputs, not just dynamics functions. This can be used  by downstream packages to define functions such as cost functions or constraints. This page details the API behind this abstraction, which is used quite heavily  to set up the functionality for defining dynamics models. This should provide the  insight into the internal workings of the package.","category":"page"},{"location":"functionbase.html#The-AbstractFunction-Type-1","page":"AbstractFunction API","title":"The AbstractFunction Type","text":"","category":"section"},{"location":"functionbase.html#","page":"AbstractFunction API","title":"AbstractFunction API","text":"AbstractFunction\ndims\ninput_dim","category":"page"},{"location":"functionbase.html#RobotDynamics.AbstractFunction","page":"AbstractFunction API","title":"RobotDynamics.AbstractFunction","text":"AbstractFunction\n\nA function of the form:\n\ny = f(xu t)\n\nwhere x is a state vector of size n and u is a control input of size m for some  dynamical system.  The output y is of size p.  Here t represents any number of optional extra parameters to the function (such as time,  time step, etc.).\n\nThe dimensions n, m, and p can  be queried individual by calling state_dim, control_dim, and ouput_dim or  collectively via dims.\n\nEvaluation\n\nAn AbstractFunction can be evaluated in-place by calling any of \n\nevaluate!(fun, y, z::AbstractKnotPoint)\nevaluate!(fun, y, x, u, p)\nevaluate!(fun, y, x, u)\n\nThe top method should be preferred by generic APIs.\n\nThe function can also be evaluated out-of-place (generally returning a  StaticArrays.SVector) by calling any of\n\nevaluate(fun, z::AbstractKnotPoint)\nevaluate(fun, x, u, p)\nevaluate(fun, x, u)\n\nAlternatively, the user can dispatch on FunctionSignature by calling\n\nevaluate!(::FunctionSignature, fun, y, z::AbstractKnotPoint)\n\nJacobians\n\nThe Jacobian of f(xu) with respect to both x and u can be computed  by calling the following function:\n\njacobian!(::FunctionSignature, ::DiffMethod, fun, J, y, z::AbstractKnotPoint)\n\nWhere J is the Jacobian of size (p, n + m) and y is provided as an extra storage  vector for evaluating the Jacobian. Some users may whish to store the function output value in this vector if evaluating the Jacobian and output value together offers some  computational savings, but this behavior is left to the user to implement on their  particular function.\n\nA user-defined Jacobian, called by passing the UserDefined DiffMethod,  can be implemented for the function by defining any of the following methods for  the AbstractFunction:\n\njacobian!(fun, J, y, z::AbstractKnotPoint)\njacobian!(fun, J, y, x, u, p)\njacobian!(fun, J, y, x, u)\n\nFunctions of just the state or control\n\nAlternatively, the function can also be limited to an input of just the state or control  by defining the FunctionInputs trait. See trait documentation for more  information.\n\nConvenience functions\n\nThe methods fill(fun, v), randn(fun), rand(fun), and zeros(fun) are defined that provide a tuple with a state and control vector initialized using the corresponding function. The data type can be specified as the first argument for randn, rand, and  zeros.\n\n\n\n\n\n","category":"type"},{"location":"functionbase.html#RobotDynamics.dims","page":"AbstractFunction API","title":"RobotDynamics.dims","text":"dims(fun::AbstractFunction)\n\nGet the tuple (n,m,p) where n is the dimension of the state vector, m is the  dimension of the control vector, and p is the output dimension of the function.\n\n\n\n\n\n","category":"function"},{"location":"functionbase.html#RobotDynamics.input_dim","page":"AbstractFunction API","title":"RobotDynamics.input_dim","text":"input_dim(fun::AbstractFunction)\n\nGet the dimension of the inputs to the function. Will be equal to n + m for  a StateVector function, n for a StateOnly function, and m for a ControlOnly function.\n\n\n\n\n\n","category":"function"},{"location":"functionbase.html#Traits-on-AbstractFunction-1","page":"AbstractFunction API","title":"Traits on AbstractFunction","text":"","category":"section"},{"location":"functionbase.html#","page":"AbstractFunction API","title":"AbstractFunction API","text":"FunctionSignature\nDiffMethod\nStateVectorType\nEuclideanState\nRotationState\nstatevectortype\nFunctionInputs\nfunctioninputs","category":"page"},{"location":"functionbase.html#RobotDynamics.FunctionSignature","page":"AbstractFunction API","title":"RobotDynamics.FunctionSignature","text":"FunctionSignature\n\nSpecifies which function signature to call when evaluating the function, must be  either StaticReturn or InPlace. The default signature for a function can be  queried via default_signature(fun).\n\n\n\n\n\n","category":"type"},{"location":"functionbase.html#RobotDynamics.DiffMethod","page":"AbstractFunction API","title":"RobotDynamics.DiffMethod","text":"DiffMethod\n\nRepresents the method used to evaluate the Jacobian of the function. Allows the  user to implement multiple methods and switch between them as needed. The following methods are provided:\n\nForwardAD: forward-mode automatic differentiation using   ForwardDiff.jl\nFiniteDifference: finite difference approximation using   FiniteDiff.jl\nUserDefined: analytical function defined by the user.\n\nThe UserDefined method can be provided by defining any of the following methods  on your AbstractFunction:\n\njacobian!(fun, J, y, z::AbstractKnotPoint)\njacobian!(fun, J, y, x, u, p)\njacobian!(fun, J, y, x, u)\n\nThe other two modes must be explicitly defined on your function, since some functions  may wish to tailor the method to their particular function.  Efficient default  implementations can be defined automatically via the @autodiff macro.\n\n\n\n\n\n","category":"type"},{"location":"functionbase.html#RobotDynamics.StateVectorType","page":"AbstractFunction API","title":"RobotDynamics.StateVectorType","text":"StateVectorType\n\nA trait defined on an AbstractFunction, describing how state vectors are composed  and how the error state, or the \"difference\" between two vectors, is computed. These \"error states\" should be Euclidean vectors, and can have a different dimension than  the original state vectors. \n\nThe following types are provided by RobotDynamics:\n\nEuclideanState\nRotationState\n\nDefining a new state vector type\n\nTo define a custom state vector type (e.g. NewStateType), you need to implement  the function that calculates the difference between state vectors, as well the  \"error state Jacobian\" and it's derivative. First, you must specify the dimension of the error state by defining\n\nerrstate_dim(::NewStateType, fun::AbstractFunction)\n\nThen you define method that calculates the error state between two state vectors: \n\nstate_diff!(::NewStateType, model, dx, x, x0)\n\nwhere dx should have dimension e = output_dim(model) and x and x0 should  have dimension n = state_dim(model).\n\nThe other piece of information we need is the \"error state Jacobian.\" This is the  first-order approximation of the mapping from local error state values to the true  state vector. Let x ⊗ x0 be the composition of two state vectors, and let φ be  the function that maps a Euclidean error state δx to a state vector. The error  state Jacobian is the Jacobian of x ⊗ φ(δx) with respect to δx, taking the limit  as δx → 0. The resulting function is solely a function of the state x, and is  implemented with the following function:\n\nerrstate_jacobian!(::NewStateType, model, G, x)\n\nwhere G has dimensions (n,e).\n\nWe'll also need the derivative of this function. For computational efficiency,  we compute the Jacobian of the error state Jacobian transposed with some vector x̄, where x̄ is state vector of size (n,). More precisely, it is the Hessian of \n\nmath \\bar{x}^T (x \\otimes \\varphi(\\delta x))` This function is calculated using\n\n∇errstatef_jacobian!(::NewStateType, model, ∇G, x, xbar)\n\nwhere ∇G is of size (e,e).\n\n\n\n\n\n","category":"type"},{"location":"functionbase.html#RobotDynamics.EuclideanState","page":"AbstractFunction API","title":"RobotDynamics.EuclideanState","text":"EuclideanState\n\nThe space of standard Euclidean vectors, where composition is element-wise addition,  and the error state is just element-wise subtraction.\n\n\n\n\n\n","category":"type"},{"location":"functionbase.html#RobotDynamics.RotationState","page":"AbstractFunction API","title":"RobotDynamics.RotationState","text":"RotationState\n\nThe space of vectors composes of Euclidean states intermixed with 3D rotations,  represented using any 3 or 4-parameter representation (usually unit quaternions). The error state Jacobians and error state calculation are all calculating using  Rotations.jl.\n\n\n\n\n\n","category":"type"},{"location":"functionbase.html#RobotDynamics.statevectortype","page":"AbstractFunction API","title":"RobotDynamics.statevectortype","text":"statevectortype\n\nQueries the StateVectorType trait on a function.\n\n\n\n\n\n","category":"function"},{"location":"functionbase.html#RobotDynamics.FunctionInputs","page":"AbstractFunction API","title":"RobotDynamics.FunctionInputs","text":"FunctionInputs\n\nA trait of an AbstractFunction that specified the inputs to the function.  By default, the input is assumed to be both the state and the control vector, along with  any extra parameters. This trait allows the user to change this assumption, defining  functions on just the state or control vectors. The number of columns in the Jacobian will change accordingly, and can be queried via input_dim. Functions of  just the state or control are not allowed to take in any extra parameters as arguments.\n\nThis trait is queried via functioninputs(fun).\n\nThe following three options are provided:\n\nStateControl: a function of the form y = f(xu) (default)\nStateOnly: a function of the form y = f(x)\nControlOnly: a function of the form y = f(u)\n\nWhen defining methods for these functions, you need to disambiguate methods of the form\n\nevaluate(fun::AbstractFunction, z::AbstractKnotPoint)\n\nfrom \n\nevaluate(fun::MyStateOnlyFunction, x)\n\nIt's not enough to annotate x as an AbstractVector because  AbstractKnotPoint <: AbstractVector. For most cases, the RobotDynamics.DataVector  type should be sufficient to accomplish this. For StateOnly or ControlOnly functions,  your methods should look like:\n\nevaluate(fun::MyFunction, x::RobotDynamics.DataVector)\nevaluate!(fun::MyFunction, y, x::RobotDynamics.DataVector)\njacobian!(fun::MyFunction, J, y, x::RobotDynamics.DataVector)\n\n\n\n\n\n","category":"type"},{"location":"functionbase.html#RobotDynamics.functioninputs","page":"AbstractFunction API","title":"RobotDynamics.functioninputs","text":"functioninputs(fun::AbstractFunction)\n\nGet the FunctionInputs trait on the function, specifying whether the  function takes as input both state and control vectors (default), or just the  state or control vector independently.\n\n\n\n\n\n","category":"function"}]
}
