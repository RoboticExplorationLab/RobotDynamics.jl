<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AbstractFunction API · RobotDynamics</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">RobotDynamics</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><span class="tocitem">Dynamics Models</span><ul><li><a class="tocitem" href="continuous.html">Continuous Dynamics</a></li><li><a class="tocitem" href="discrete.html">Discrete Dynamics</a></li></ul></li><li><span class="tocitem">Rotations</span><ul><li><a class="tocitem" href="rotationstate.html">The Rotation State</a></li></ul></li><li><span class="tocitem">Important Types</span><ul><li><a class="tocitem" href="knotpoints.html">Knot Points</a></li><li><a class="tocitem" href="trajectories.html">Trajectories</a></li></ul></li><li><span class="tocitem">Internal API</span><ul><li class="is-active"><a class="tocitem" href="functionbase.html"><code>AbstractFunction</code> API</a><ul class="internal"><li><a class="tocitem" href="#The-AbstractFunction-Type-1"><span>The <code>AbstractFunction</code> Type</span></a></li><li><a class="tocitem" href="#Traits-on-AbstractFunction-1"><span>Traits on <code>AbstractFunction</code></span></a></li></ul></li><li><a class="tocitem" href="scalarfunction.html">Scalar Functions</a></li><li><a class="tocitem" href="autodiff.html">Differentiation API</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Internal API</a></li><li class="is-active"><a href="functionbase.html"><code>AbstractFunction</code> API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="functionbase.html"><code>AbstractFunction</code> API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/master/docs/src/functionbase.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="AbstractFunction-1"><a class="docs-heading-anchor" href="#AbstractFunction-1"><code>AbstractFunction</code> API</a><a class="docs-heading-anchor-permalink" href="#AbstractFunction-1" title="Permalink"></a></h1><p>RobotDynamics sets up a unified framework for evaluating functions accepting a  state and control vector as inputs, not just dynamics functions. This can be used  by downstream packages to define functions such as cost functions or constraints. This page details the API behind this abstraction, which is used quite heavily  to set up the functionality for defining dynamics models. This should provide the  insight into the internal workings of the package.</p><h2 id="The-AbstractFunction-Type-1"><a class="docs-heading-anchor" href="#The-AbstractFunction-Type-1">The <code>AbstractFunction</code> Type</a><a class="docs-heading-anchor-permalink" href="#The-AbstractFunction-Type-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.AbstractFunction" href="#RobotDynamics.AbstractFunction"><code>RobotDynamics.AbstractFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractFunction</code></pre><p>A function of the form:</p><div>\[y = f(x,u; t)\]</div><p>where <span>$x$</span> is a state vector of size <code>n</code> and <span>$u$</span> is a control input of size <code>m</code> for some  dynamical system.  The output <span>$y$</span> is of size <code>p</code>.  Here <span>$t$</span> represents any number of optional extra parameters to the function (such as time,  time step, etc.).</p><p>The dimensions <code>n</code>, <code>m</code>, and <code>p</code> can  be queried individual by calling <code>state_dim</code>, <code>control_dim</code>, and <code>ouput_dim</code> or  collectively via <a href="functionbase.html#RobotDynamics.dims"><code>dims</code></a>.</p><p><strong>Evaluation</strong></p><p>An <code>AbstractFunction</code> can be evaluated in-place by calling any of </p><pre><code class="language-none">evaluate!(fun, y, z::AbstractKnotPoint)
evaluate!(fun, y, x, u, p)
evaluate!(fun, y, x, u)</code></pre><p>The top method should be preferred by generic APIs.</p><p>The function can also be evaluated out-of-place (generally returning a  <code>StaticArrays.SVector</code>) by calling any of</p><pre><code class="language-none">evaluate(fun, z::AbstractKnotPoint)
evaluate(fun, x, u, p)
evaluate(fun, x, u)</code></pre><p>Alternatively, the user can dispatch on <a href="functionbase.html#RobotDynamics.FunctionSignature"><code>FunctionSignature</code></a> by calling</p><pre><code class="language-none">evaluate!(::FunctionSignature, fun, y, z::AbstractKnotPoint)</code></pre><p><strong>Jacobians</strong></p><p>The Jacobian of <span>$f(x,u)$</span> with respect to both <span>$x$</span> and <span>$u$</span> can be computed  by calling the following function:</p><pre><code class="language-none">jacobian!(::FunctionSignature, ::DiffMethod, fun, J, y, z::AbstractKnotPoint)</code></pre><p>Where <code>J</code> is the Jacobian of size <code>(p, n + m)</code> and <code>y</code> is provided as an extra storage  vector for evaluating the Jacobian. Some users may whish to store the function output value in this vector if evaluating the Jacobian and output value together offers some  computational savings, but this behavior is left to the user to implement on their  particular function.</p><p>A user-defined Jacobian, called by passing the <code>UserDefined</code> <a href="functionbase.html#RobotDynamics.DiffMethod"><code>DiffMethod</code></a>,  can be implemented for the function by defining any of the following methods for  the <code>AbstractFunction</code>:</p><pre><code class="language-none">jacobian!(fun, J, y, z::AbstractKnotPoint)
jacobian!(fun, J, y, x, u, p)
jacobian!(fun, J, y, x, u)</code></pre><p><strong>Functions of just the state or control</strong></p><p>Alternatively, the function can also be limited to an input of just the state or control  by defining the <a href="functionbase.html#RobotDynamics.FunctionInputs"><code>FunctionInputs</code></a> trait. See trait documentation for more  information.</p><p><strong>Convenience functions</strong></p><p>The methods <code>fill(fun, v)</code>, <code>randn(fun)</code>, <code>rand(fun)</code>, and <code>zeros(fun)</code> are defined that provide a tuple with a state and control vector initialized using the corresponding function. The data type can be specified as the first argument for <code>randn</code>, <code>rand</code>, and  <code>zeros</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/cf8f4f7f527c39c8a9b1b89b322268f14cd54321/src/functionbase.jl#L1-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.dims" href="#RobotDynamics.dims"><code>RobotDynamics.dims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dims(fun::AbstractFunction)</code></pre><p>Get the tuple <code>(n,m,p)</code> where <code>n</code> is the dimension of the state vector, <code>m</code> is the  dimension of the control vector, and <code>p</code> is the output dimension of the function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/cf8f4f7f527c39c8a9b1b89b322268f14cd54321/src/functionbase.jl#L124-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.input_dim" href="#RobotDynamics.input_dim"><code>RobotDynamics.input_dim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">input_dim(fun::AbstractFunction)</code></pre><p>Get the dimension of the inputs to the function. Will be equal to <code>n + m</code> for  a <code>StateVector</code> function, <code>n</code> for a <code>StateOnly</code> function, and <code>m</code> for a <code>ControlOnly</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/cf8f4f7f527c39c8a9b1b89b322268f14cd54321/src/functionbase.jl#L186-L192">source</a></section></article><h2 id="Traits-on-AbstractFunction-1"><a class="docs-heading-anchor" href="#Traits-on-AbstractFunction-1">Traits on <code>AbstractFunction</code></a><a class="docs-heading-anchor-permalink" href="#Traits-on-AbstractFunction-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.FunctionSignature" href="#RobotDynamics.FunctionSignature"><code>RobotDynamics.FunctionSignature</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FunctionSignature</code></pre><p>Specifies which function signature to call when evaluating the function, must be  either <code>StaticReturn</code> or <code>InPlace</code>. The default signature for a function can be  queried via <code>default_signature(fun)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/cf8f4f7f527c39c8a9b1b89b322268f14cd54321/src/functionbase.jl#L71-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.DiffMethod" href="#RobotDynamics.DiffMethod"><code>RobotDynamics.DiffMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiffMethod</code></pre><p>Represents the method used to evaluate the Jacobian of the function. Allows the  user to implement multiple methods and switch between them as needed. The following methods are provided:</p><ul><li><code>ForwardAD</code>: forward-mode automatic differentiation using   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a></li><li><code>FiniteDifference</code>: finite difference approximation using   <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a></li><li><code>UserDefined</code>: analytical function defined by the user.</li><li><code>ImplicitFunctionTheorem</code>: Only available for a <a href="discrete.html#RobotDynamics.DiscretizedDynamics"><code>DiscretizedDynamics</code></a> model  with an an implicit integrator. Parameterized by the <code>DiffMethod</code> of the underlying   continuous dynamics model. </li></ul><p>The <code>UserDefined</code> method can be provided by defining any of the following methods  on your <a href="functionbase.html#RobotDynamics.AbstractFunction"><code>AbstractFunction</code></a>:</p><pre><code class="language-none">jacobian!(fun, J, y, z::AbstractKnotPoint)
jacobian!(fun, J, y, x, u, p)
jacobian!(fun, J, y, x, u)</code></pre><p>The other two modes must be explicitly defined on your function, since some functions  may wish to tailor the method to their particular function.  Efficient default  implementations can be defined automatically via the <a href="autodiff.html#RobotDynamics.@autodiff"><code>@autodiff</code></a> macro.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/cf8f4f7f527c39c8a9b1b89b322268f14cd54321/src/functionbase.jl#L82-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.StateVectorType" href="#RobotDynamics.StateVectorType"><code>RobotDynamics.StateVectorType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StateVectorType</code></pre><p>A trait defined on an <code>AbstractFunction</code>, describing how state vectors are composed  and how the error state, or the &quot;difference&quot; between two vectors, is computed. These &quot;error states&quot; should be Euclidean vectors, and can have a different dimension than  the original state vectors. </p><p>The following types are provided by RobotDynamics:</p><ul><li><a href="functionbase.html#RobotDynamics.EuclideanState"><code>EuclideanState</code></a></li><li><a href="functionbase.html#RobotDynamics.RotationState"><code>RotationState</code></a></li></ul><p><strong>Defining a new state vector type</strong></p><p>To define a custom state vector type (e.g. <code>NewStateType</code>), you need to implement  the function that calculates the difference between state vectors, as well the  &quot;error state Jacobian&quot; and it&#39;s derivative. First, you must specify the dimension of the error state by defining</p><pre><code class="language-none">errstate_dim(::NewStateType, fun::AbstractFunction)</code></pre><p>Then you define method that calculates the error state between two state vectors: </p><pre><code class="language-none">state_diff!(::NewStateType, model, dx, x, x0)</code></pre><p>where <code>dx</code> should have dimension <code>e = output_dim(model)</code> and <code>x</code> and <code>x0</code> should  have dimension <code>n = state_dim(model)</code>.</p><p>The other piece of information we need is the &quot;error state Jacobian.&quot; This is the  first-order approximation of the mapping from local error state values to the true  state vector. Let <code>x ⊗ x0</code> be the composition of two state vectors, and let <code>φ</code> be  the function that maps a Euclidean error state <code>δx</code> to a state vector. The error  state Jacobian is the Jacobian of <code>x ⊗ φ(δx)</code> with respect to <code>δx</code>, taking the limit  as <code>δx → 0</code>. The resulting function is solely a function of the state <code>x</code>, and is  implemented with the following function:</p><pre><code class="language-none">errstate_jacobian!(::NewStateType, model, G, x)</code></pre><p>where <code>G</code> has dimensions <code>(n,e)</code>.</p><p>We&#39;ll also need the derivative of this function. For computational efficiency,  we compute the Jacobian of the error state Jacobian transposed with some vector <code>x̄</code>, where <code>x̄</code> is state vector of size <code>(n,)</code>. More precisely, it is the Hessian of </p><p><code>math \bar{x}^T (x \otimes \varphi(\delta x))</code>` This function is calculated using</p><pre><code class="language-none">∇errstatef_jacobian!(::NewStateType, model, ∇G, x, xbar)</code></pre><p>where <code>∇G</code> is of size <code>(e,e)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/cf8f4f7f527c39c8a9b1b89b322268f14cd54321/src/statevectortype.jl#L2-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.EuclideanState" href="#RobotDynamics.EuclideanState"><code>RobotDynamics.EuclideanState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EuclideanState</code></pre><p>The space of standard Euclidean vectors, where composition is element-wise addition,  and the error state is just element-wise subtraction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/cf8f4f7f527c39c8a9b1b89b322268f14cd54321/src/statevectortype.jl#L57-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.RotationState" href="#RobotDynamics.RotationState"><code>RobotDynamics.RotationState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RotationState</code></pre><p>The space of vectors composes of Euclidean states intermixed with 3D rotations,  represented using any 3 or 4-parameter representation (usually unit quaternions). The error state Jacobians and error state calculation are all calculating using  <a href="https://github.com/JuliaGeometry/Rotations.jl">Rotations.jl</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/cf8f4f7f527c39c8a9b1b89b322268f14cd54321/src/statevectortype.jl#L65-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.statevectortype" href="#RobotDynamics.statevectortype"><code>RobotDynamics.statevectortype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">statevectortype</code></pre><p>Queries the StateVectorType trait on a function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/cf8f4f7f527c39c8a9b1b89b322268f14cd54321/src/statevectortype.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.FunctionInputs" href="#RobotDynamics.FunctionInputs"><code>RobotDynamics.FunctionInputs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FunctionInputs</code></pre><p>A trait of an <a href="functionbase.html#RobotDynamics.AbstractFunction"><code>AbstractFunction</code></a> that specified the inputs to the function.  By default, the input is assumed to be both the state and the control vector, along with  any extra parameters. This trait allows the user to change this assumption, defining  functions on just the state or control vectors. The number of columns in the Jacobian will change accordingly, and can be queried via <a href="functionbase.html#RobotDynamics.input_dim"><code>input_dim</code></a>. Functions of  just the state or control are not allowed to take in any extra parameters as arguments.</p><p>This trait is queried via <a href="functionbase.html#RobotDynamics.functioninputs"><code>functioninputs(fun)</code></a>.</p><p>The following three options are provided:</p><ul><li><code>StateControl</code>: a function of the form <span>$y = f(x,u)$</span> (default)</li><li><code>StateOnly</code>: a function of the form <span>$y = f(x)$</span></li><li><code>ControlOnly</code>: a function of the form <span>$y = f(u)$</span></li></ul><p>When defining methods for these functions, you need to disambiguate methods of the form</p><pre><code class="language-none">evaluate(fun::AbstractFunction, z::AbstractKnotPoint)</code></pre><p>from </p><pre><code class="language-none">evaluate(fun::MyStateOnlyFunction, x)</code></pre><p>It&#39;s not enough to annotate <code>x</code> as an <code>AbstractVector</code> because  <code>AbstractKnotPoint &lt;: AbstractVector</code>. For most cases, the <code>RobotDynamics.DataVector</code>  type should be sufficient to accomplish this. For <code>StateOnly</code> or <code>ControlOnly</code> functions,  your methods should look like:</p><pre><code class="language-none">evaluate(fun::MyFunction, x::RobotDynamics.DataVector)
evaluate!(fun::MyFunction, y, x::RobotDynamics.DataVector)
jacobian!(fun::MyFunction, J, y, x::RobotDynamics.DataVector)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/cf8f4f7f527c39c8a9b1b89b322268f14cd54321/src/functionbase.jl#L137-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.functioninputs" href="#RobotDynamics.functioninputs"><code>RobotDynamics.functioninputs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">functioninputs(fun::AbstractFunction)</code></pre><p>Get the <a href="functionbase.html#RobotDynamics.FunctionInputs"><code>FunctionInputs</code></a> trait on the function, specifying whether the  function takes as input both state and control vectors (default), or just the  state or control vector independently.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/cf8f4f7f527c39c8a9b1b89b322268f14cd54321/src/functionbase.jl#L177-L183">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="trajectories.html">« Trajectories</a><a class="docs-footer-nextpage" href="scalarfunction.html">Scalar Functions »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 11 March 2022 17:34">Friday 11 March 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
