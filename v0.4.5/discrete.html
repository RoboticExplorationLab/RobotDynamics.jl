<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Discrete Dynamics · RobotDynamics</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">RobotDynamics</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><span class="tocitem">Dynamics Models</span><ul><li><a class="tocitem" href="continuous.html">Continuous Dynamics</a></li><li class="is-active"><a class="tocitem" href="discrete.html">Discrete Dynamics</a><ul class="internal"><li><a class="tocitem" href="#Discrete-Dynamics-type-1"><span>Discrete Dynamics type</span></a></li><li><a class="tocitem" href="#Methods-for-Discrete-Dynamics-models-1"><span>Methods for Discrete Dynamics models</span></a></li><li><a class="tocitem" href="#Discretizing-Continuous-Models-1"><span>Discretizing Continuous Models</span></a></li><li><a class="tocitem" href="#Implemented-Integrators-1"><span>Implemented Integrators</span></a></li></ul></li></ul></li><li><span class="tocitem">Rotations</span><ul><li><a class="tocitem" href="rotationstate.html">The Rotation State</a></li></ul></li><li><span class="tocitem">Important Types</span><ul><li><a class="tocitem" href="knotpoints.html">Knot Points</a></li><li><a class="tocitem" href="trajectories.html">Trajectories</a></li></ul></li><li><span class="tocitem">Internal API</span><ul><li><a class="tocitem" href="functionbase.html"><code>AbstractFunction</code> API</a></li><li><a class="tocitem" href="scalarfunction.html">Scalar Functions</a></li><li><a class="tocitem" href="autodiff.html">Differentiation API</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Dynamics Models</a></li><li class="is-active"><a href="discrete.html">Discrete Dynamics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="discrete.html">Discrete Dynamics</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/master/docs/src/discrete.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Discrete-Dynamics-1"><a class="docs-heading-anchor" href="#Discrete-Dynamics-1">Discrete Dynamics</a><a class="docs-heading-anchor-permalink" href="#Discrete-Dynamics-1" title="Permalink"></a></h1><p>This page provides the API for discrete dynamics models.</p><ul><li><a href="discrete.html#Discrete-Dynamics-1">Discrete Dynamics</a></li><ul><li><a href="discrete.html#Discrete-Dynamics-type-1">Discrete Dynamics type</a></li><li><a href="discrete.html#Methods-for-Discrete-Dynamics-models-1">Methods for Discrete Dynamics models</a></li><li><a href="discrete.html#Discretizing-Continuous-Models-1">Discretizing Continuous Models</a></li><li><a href="discrete.html#Implemented-Integrators-1">Implemented Integrators</a></li><ul><li><a href="discrete.html#Explicit-1">Explicit</a></li><li><a href="discrete.html#Implicit-1">Implicit</a></li><li><a href="discrete.html#Interal-API-1">Interal API</a></li></ul></ul></ul><h2 id="Discrete-Dynamics-type-1"><a class="docs-heading-anchor" href="#Discrete-Dynamics-type-1">Discrete Dynamics type</a><a class="docs-heading-anchor-permalink" href="#Discrete-Dynamics-type-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.DiscreteDynamics" href="#RobotDynamics.DiscreteDynamics"><code>RobotDynamics.DiscreteDynamics</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiscreteDynamics</code></pre><p>A dynamics model of the form</p><div>\[x_{k+1} = f(x_k, u_k)\]</div><p>where <span>$x$</span> is the <code>n</code>-dimensional state vector and <span>$u$</span> is the <code>m</code>-dimensional control vector. The following methods should be defined on any model:</p><pre><code class="language-none">state_dim(model)
control_dim(model)</code></pre><p>The output dimension <code>output_dim</code> is automatically defined to be equal to the  state dimension. </p><p><strong>Defining the dynamics</strong></p><p>To define the dynamics using out-of-place (returning an SVector) evaluation,  the user must define one of the following:</p><pre><code class="language-none">discrete_dynamics(model, z::AbstractKnotPoint)
discrete_dynamics(model, x, u, t, dt)</code></pre><p>where <code>t</code> is the current time and <code>dt</code> is the time step between <span>$x_k$</span> and <span>$x_{k+1}$</span>.</p><p>The user shouldn&#39;t assume that the inputs are static arrays, although for best  computational performance these methods should be called by passing in static arrays.</p><p>To define the dynamics using in-place evaluation, the user must define one of the following:</p><pre><code class="language-none">discrete_dynamics!(model, xn, z::AbstractKnotPoint)
discrete_dynamics!(model, xn, x, u, t, dt)</code></pre><p>Either of these function can be called by dispatching on the <a href="functionbase.html#RobotDynamics.FunctionSignature"><code>FunctionSignature</code></a> using:</p><pre><code class="language-none">discrete_dynamics!(sig, model, xn, z::AbstractKnotPoint)</code></pre><p><strong>Discretizing continuous dynamics</strong></p><p>This type is the abstract type representing all discrete dynamics systems, whether  or not they are approximations of continuous systems. Users can choose to implement  their dynamics directly in discrete time using this interface, or can use  <a href="discrete.html#RobotDynamics.DiscretizedDynamics"><code>DiscretizedDynamics</code></a> to discretize a continuous time system.</p><p><strong>Implicit dynamics functions</strong></p><p>Sometimes continuous time systems are approximated using implicit integrators of the  form </p><div>\[d(x_{k+1}, u_{k+1}, x_k, u_k) = 0\]</div><p>To evaluate these types of systems, use the <a href="discrete.html#RobotDynamics.dynamics_error"><code>dynamics_error</code></a> and  <a href="discrete.html#RobotDynamics.dynamics_error!"><code>dynamics_error!</code></a> methods, which will return the output of <code>f</code> for  two consecutive knot points. The default functions such as <code>discrete_dynamics</code> or <code>jacobian!</code> are not defined for these types of systems.</p><p><strong>Simulating the dynamics</strong></p><p>Use <a href="discrete.html#RobotDynamics.propagate_dynamics!"><code>propagate_dynamics!</code></a> to conveniently save the next state directly into  the state vector of another <a href="knotpoints.html#RobotDynamics.KnotPoint"><code>KnotPoint</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/22020a22da96f83b59ecc43f025ce3de01bf65ed/src/discrete_dynamics.jl#L1-L63">source</a></section></article><h2 id="Methods-for-Discrete-Dynamics-models-1"><a class="docs-heading-anchor" href="#Methods-for-Discrete-Dynamics-models-1">Methods for Discrete Dynamics models</a><a class="docs-heading-anchor-permalink" href="#Methods-for-Discrete-Dynamics-models-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.discrete_dynamics" href="#RobotDynamics.discrete_dynamics"><code>RobotDynamics.discrete_dynamics</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">discrete_dynamics(model, z::AbstractKnotPoint)
discrete_dynamics(model, x, u, t, dt)</code></pre><p>Evaluate the discrete time dynamics, returning the output <span>$x_{k+1}$</span>. For best  performance, the output should be a <code>StaticArrays.SVector</code>. This method is called  when using the <code>StaticReturn</code> <a href="functionbase.html#RobotDynamics.FunctionSignature"><code>FunctionSignature</code></a>.</p><p>Calling <code>evaluate</code> on a <a href="discrete.html#RobotDynamics.DiscreteDynamics"><code>DiscreteDynamics</code></a> model will call this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/22020a22da96f83b59ecc43f025ce3de01bf65ed/src/discrete_dynamics.jl#L70-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.discrete_dynamics!" href="#RobotDynamics.discrete_dynamics!"><code>RobotDynamics.discrete_dynamics!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">discrete_dynamics!(model, xn, z::AbstractKnotPoint)
discrete_dynamics!(model, xn, x, u, t, dt)</code></pre><p>Evaluate the discrete time dynamics, storing the output in <code>xn</code>.  This method is called when using the <code>InPlace</code> <a href="functionbase.html#RobotDynamics.FunctionSignature"><code>FunctionSignature</code></a>.</p><p>Calling <code>evaluate!</code> on a <a href="discrete.html#RobotDynamics.DiscreteDynamics"><code>DiscreteDynamics</code></a> model will call this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/22020a22da96f83b59ecc43f025ce3de01bf65ed/src/discrete_dynamics.jl#L85-L93">source</a></section><section><div><pre><code class="language-none">discrete_dynamics!(sig, xn, z::AbstractKnotPoint)</code></pre><p>Evaluate the discrete dynamics function, storing the output in <code>xn</code>, using the  <a href="functionbase.html#RobotDynamics.FunctionSignature"><code>FunctionSignature</code></a> <code>sig</code> to determine which method to call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/22020a22da96f83b59ecc43f025ce3de01bf65ed/src/discrete_dynamics.jl#L99-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.dynamics_error" href="#RobotDynamics.dynamics_error"><code>RobotDynamics.dynamics_error</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dynamics_error(model, z2, z1)</code></pre><p>Evaluate the dynamics error between two knot points for a <a href="discrete.html#RobotDynamics.DiscreteDynamics"><code>DiscreteDynamics</code></a>  model. In general, this function takes the form:</p><div>\[d(x_{k+1}, u_{k+1}, x_k, u_k) = 0\]</div><p>For explicit integration methods of the form <span>$x_{k+1} = f(x_k, u_k)$</span>, this is just</p><div>\[d(x_k, u_k) - x_{k+1} = 0\]</div><p>This is the method that should be used with implicit integration methods.</p><p>This form is the out-of-place form that should, in general, return a  <code>StaticVectors.SVector</code>. See <a href="discrete.html#RobotDynamics.dynamics_error!"><code>dynamics_error!</code></a> for the in-place method.</p><p>The Jacobian of this function is evaluated by calling <a href="discrete.html#RobotDynamics.dynamics_error_jacobian!"><code>dynamics_error_jacobian!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/22020a22da96f83b59ecc43f025ce3de01bf65ed/src/discrete_dynamics.jl#L115-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.dynamics_error!" href="#RobotDynamics.dynamics_error!"><code>RobotDynamics.dynamics_error!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dynamics_error!(model, y2, y1, z2, z1)</code></pre><p>Evaluate the dynamics error between two knot points for a <a href="discrete.html#RobotDynamics.DiscreteDynamics"><code>DiscreteDynamics</code></a> model. The output is stored in <code>y2</code>, and <code>y1</code> is provided as a extra input that can be used  to store temporary results. Any specific usage of this variable is left to the user.</p><p>See <a href="discrete.html#RobotDynamics.dynamics_error"><code>dynamics_error</code></a> for more details on this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/22020a22da96f83b59ecc43f025ce3de01bf65ed/src/discrete_dynamics.jl#L140-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.dynamics_error_jacobian!" href="#RobotDynamics.dynamics_error_jacobian!"><code>RobotDynamics.dynamics_error_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dynamics_error_jacobian!(sig, diff, model, J2, J1, y2, y1, z2, z1)</code></pre><p>Evaluate the Jacobian of <a href="discrete.html#RobotDynamics.dynamics_error"><code>dynamics_error</code></a>. The derivative with respect to  the first knotpoint <code>z1</code> should be stored in <code>J1</code>, and the derivative with respect to  the second knotpoint <code>z2</code> should be stored in <code>J2</code>. The variables <code>y2</code> and <code>y1</code> should be  vectors of the size of the output dimension (usually the state dimension) and are provided  as extra cache variables whose usage is left to be determined by the user. For example,  a user could choose to evaluate the dynamics error and store the result in one of these  variables to evaluate the error and it&#39;s Jacobian at the same time.</p><p>Both <code>J2</code> and <code>J1</code> must have dimensions <code>(p, n + m)</code> where <code>n</code>, <code>m</code>, and <code>p</code> are the output  of <code>state_dim</code>, <code>control_dim</code>, and <code>output_dim</code>. Usually <code>p = n</code>.</p><p>Note that for explicit integration methods of the form <code>x_{k+1} = f(x_k, u_k)</code> <code>J2</code> should  be equal to <code>[-I(n) zeros(n,m)]</code>.</p><p><strong>Implementing on a custom type</strong></p><p>To implement this function on a new <a href="discrete.html#RobotDynamics.DiscreteDynamics"><code>DiscreteDynamics</code></a> model, define methods  for the <a href="functionbase.html#RobotDynamics.FunctionSignature"><code>FunctionSignature</code></a> and <a href="functionbase.html#RobotDynamics.DiffMethod"><code>DiffMethod</code></a> of your choice. These are  automatically defined when using <a href="autodiff.html#RobotDynamics.@autodiff"><code>@autodiff</code></a> on a <a href="discrete.html#RobotDynamics.DiscreteDynamics"><code>DiscreteDynamics</code></a> model. To implement the <code>UserDefined</code> <a href="functionbase.html#RobotDynamics.DiffMethod"><code>DiffMethod</code></a>, implement the following method:</p><pre><code class="language-none">dynamics_error_jacobian!(model, J2, J1, y2, y1, 
                         z2::AbstractKnotPoint, z1::AbstractKnotPoint)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/22020a22da96f83b59ecc43f025ce3de01bf65ed/src/discrete_dynamics.jl#L161-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.propagate_dynamics!" href="#RobotDynamics.propagate_dynamics!"><code>RobotDynamics.propagate_dynamics!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">propagate_dynamics!(sig, model, z2, z1)</code></pre><p>Save the output of either <a href="discrete.html#RobotDynamics.discrete_dynamics"><code>discrete_dynamics</code></a> or <a href="discrete.html#RobotDynamics.discrete_dynamics!"><code>discrete_dynamics!</code></a> evaluated using <code>z1</code> into the state vector of <code>z2</code>. Useful for simulating discrete systems  forward in time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/22020a22da96f83b59ecc43f025ce3de01bf65ed/src/discrete_dynamics.jl#L210-L216">source</a></section></article><h2 id="Discretizing-Continuous-Models-1"><a class="docs-heading-anchor" href="#Discretizing-Continuous-Models-1">Discretizing Continuous Models</a><a class="docs-heading-anchor-permalink" href="#Discretizing-Continuous-Models-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.DiscretizedDynamics" href="#RobotDynamics.DiscretizedDynamics"><code>RobotDynamics.DiscretizedDynamics</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiscretizedDynamics</code></pre><p>Represents a <a href="discrete.html#RobotDynamics.DiscreteDynamics"><code>DiscreteDynamics</code></a> model formed by integrating a continuous  dynamics model. It is essentially a <a href="continuous.html#RobotDynamics.ContinuousDynamics"><code>ContinuousDynamics</code></a> paired with a  <a href="discrete.html#RobotDynamics.QuadratureRule"><code>QuadratureRule</code></a> that defines how to use the <a href="continuous.html#RobotDynamics.dynamics!"><code>dynamics!</code></a> function  to get a <a href="discrete.html#RobotDynamics.discrete_dynamics!"><code>discrete_dynamics!</code></a> function. </p><p><strong>Constructor</strong></p><p>A <code>DiscretedDynamics</code> type can be created using either of the following signatures:</p><pre><code class="language-none">DiscretizedDynamics(dynamics::ContinuousDynamics, Q::QuadratureRule)
DiscretizedDynamics{Q}(dynamics::ContinuousDynamics) where Q &lt;: QuadratureRule</code></pre><p>In the second case, the integrator is constructed by calling  <code>Q(state_dim(dynamics), control_dim(dynamics))</code>.</p><p><strong>Usage</strong></p><p>A <code>DiscretizedDynamics</code> model is used just like any other <a href="discrete.html#RobotDynamics.DiscreteDynamics"><code>DiscreteDynamics</code></a> model. The state, control, and error state dimensions are all taken from the  continuous time dynamics model, and the <a href="functionbase.html#RobotDynamics.StateVectorType"><code>StateVectorType</code></a> and  <a href="functionbase.html#RobotDynamics.FunctionInputs"><code>FunctionInputs</code></a> traits are inherited from the continuous time dynamics.</p><p>The <code>default_diffmethod</code>, however, is set to <code>ForwardAD</code>, since our benchmarks show that  it is usually faster to make a single call to <code>ForwardDiff.jacobian!</code> than using the chain  rule and multiple calls to query the Jacobian of the continuous dynamics at multiple points. If the continuous model has a <code>UserDefined</code> Jacobian method, calling <code>jacobian!</code> on  a <code>DiscretizedDynamics</code> model will use the chain rule with analytical Jacobians of  the integrator. If the user wants to use a combination of ForwardDiff (or any other  differentiation method, for that matter) with the integrator, they are free to define their  own <a href="functionbase.html#RobotDynamics.DiffMethod"><code>DiffMethod</code></a> to dispatch on.</p><p><strong>Implicit Dynamics</strong></p><p>If an <a href="discrete.html#RobotDynamics.Implicit"><code>Implicit</code></a> integrator is used, the interface changes slightly. The dynamics  residual is calculated and it&#39;s Jacobian are calculated using</p><pre><code class="language-none">dynamics_error(model, z2, z1)
dynamics_error!(model, y2, y1, z2, z1)
dynamics_error_jacobian!(sig, diff, model, J2, J1, y2, y1, z2, z1)</code></pre><p>Where the dynamics residual is stored in <code>y2</code> for the in-place version, and the Jacobians  with respect to the state and control at the next and current knot points are stored in <code>J2</code> and <code>J1</code>, respectively.</p><p>Implicit dynamics integrators can also support the normal API  (see documentation for <a href="discrete.html#RobotDynamics.Implicit"><code>Implicit</code></a>). Note that calls to <code>discrete_dynamics</code> will  use a Newton&#39;s solve to calculate the next state and calls to <code>jacobian!</code> will use the  Implicit Function Theorem. In order to use the implicit function theorem to get the  Jacobians, <code>jacobian!</code> must be called using the <code>ImplicitFunctionTheorem</code>  <a href="functionbase.html#RobotDynamics.DiffMethod"><code>DiffMethod</code></a>, which also specifies the <code>DiffMethod</code> to use to on  <code>dynamics_error_jacobian!</code>.</p><p>When using Newton&#39;s method during <code>discrete_dynamics</code>, the <code>DiffMethod</code> returned by  <code>default_diffmethod</code> for the continuous dynamics model is used to evaluate the  <code>dynamics_error_jacobian!</code>. There is no option to change this at run time, since  <code>discrete_dynamics</code> and <code>discrete_dynamics!</code> do not take a <code>DiffMethod</code> as an argument.</p><p>The convergence tolerance and max number of iterations of the Newton&#39;s method can be set  using </p><pre><code class="language-none">setnewtontolerance(model::ImplicitDynamicsModel, tol)
setnewtoniters(model::ImplicitDynamicsModel, iters)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/22020a22da96f83b59ecc43f025ce3de01bf65ed/src/discretized_dynamics.jl#L106-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.QuadratureRule" href="#RobotDynamics.QuadratureRule"><code>RobotDynamics.QuadratureRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QuadratureRule</code></pre><p>Integration rule for approximating the continuous integrals for the equations of motion. Currently divided into two classes of integrators:</p><ul><li><a href="discrete.html#RobotDynamics.Explicit"><code>Explicit</code></a></li><li><a href="discrete.html#RobotDynamics.Implicit"><code>Implicit</code></a></li></ul><p><strong>Interface</strong></p><p>All integrators need to have a constructor of the form:</p><pre><code class="language-none">Q(n, m)</code></pre><p>where <code>n</code> and <code>m</code> are the state and control dimensions of the dynamical system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/22020a22da96f83b59ecc43f025ce3de01bf65ed/src/discretized_dynamics.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.Explicit" href="#RobotDynamics.Explicit"><code>RobotDynamics.Explicit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Explicit &lt;: QuadratureRule</code></pre><p>Integration rules of the form </p><div>\[x_{k+1} = f(x_k,u_k)\]</div><p>.</p><p><strong>Interface</strong></p><p>All explicit integrators need to define the following methods:</p><pre><code class="language-none">integrate(::Q, model, x, u, t, h)
integrate!(::Q, model, xn, x, u, t, h)
jacobian!(::Q, sig, model, J, xn, x, u, t, h)</code></pre><p>where <code>h</code> is the time step (i.e. <code>dt</code>). The Jacobian <code>J</code> should have size <code>(n, n + m)</code>. The <code>sig</code> is a <a href="functionbase.html#RobotDynamics.FunctionSignature"><code>FunctionSignature</code></a> that can be used to dispatch the Jacobian on  the desired function signature. For example, when using <code>StaticReturn</code> intermediate  cache variables aren&#39;t usually needed, but are when using <code>InPlace</code> methods. These cache variables can be stored in the integrator itself (see the <a href="discrete.html#RobotDynamics.ADVector"><code>ADVector</code></a> type provided by this package).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>Q</code> in these methods should be replaced by your explicit integrator,  e.g. <code>MyRungeKutta</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/22020a22da96f83b59ecc43f025ce3de01bf65ed/src/discretized_dynamics.jl#L24-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.Implicit" href="#RobotDynamics.Implicit"><code>RobotDynamics.Implicit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Implicit &lt;: QuadratureRule</code></pre><p>Integration rules of the form </p><div>\[f(x_{k+1},u_{k+1},x_k,u_k) = 0\]</div><p>.</p><p><strong>Interface</strong></p><p>All implicit integrators need to define the following methods:</p><pre><code class="language-none">dynamics_error(::Q, model, z2, z1)
dynamics_error!(::Q, model, y2, y1, z2, z1)
dynamics_error_jacobian!(::Q, sig, model, J2, J1, y2, y1, z2, z1)</code></pre><p>where <code>model</code> is a <a href="continuous.html#RobotDynamics.ContinuousDynamics"><code>ContinuousDynamics</code></a> model. For the in place method,  the output should be stored in the <code>y2</code> vector. For the Jacobian method, <code>J2</code>  holds the Jacobian with respect to the state and control of <code>z2</code> (the knot point  at the next time step) and <code>J1</code> holds the Jacobian with respect to the state  and control of <code>z1</code> (the knot point at the current time step).</p><p><strong>Treating an Implicit method as an Explicit method</strong></p><p>Implicit methods can be treated as an explicit integrator. In addition to the the  methods above that evaluate the dynamics error residual for the integrator, they  overload <code>discrete_dynamics</code>, <code>discrete_dynamics!</code>, and <code>jacobian</code>. The forward simulation functions <code>discrete_dynamics</code> and <code>discrete_dynamics!</code> use Newton&#39;s method. The dynamics  Jacobians are calculated using the Implicit Function Theorem.</p><p>If the state and control vector passed to <code>jacobian!</code> are the same as the last call  to <code>jacobian!</code>, <code>discrete_dynamics</code> or <code>discrete_dynamics!</code> the Jacobians and matrix  factorization from the Newton solve are used to speed up the computation. Note that  the factorization is only cached for <code>InPlace</code> methods, not <code>StaticReturn</code>.</p><p>To call <code>jacobian!</code> on <code>DiscretizedDynamics</code> with an implicit dynamics model, it must be  called using the <code>ImplicitFunctionTheorem</code> method, which also specified the  <a href="functionbase.html#RobotDynamics.DiffMethod"><code>DiffMethod</code></a> that should be used to evaluate <code>dynamics_error_jacobian!</code>, e.g.</p><pre><code class="language-none">jacobian!(InPlace(), ImplicitFunctionTheorem(ForwardDiff), implicitmodel, J, y, z)</code></pre><p><strong>Defining an Implicit Integrator</strong></p><p>An implicit integrator should define the signatures above for <code>dynamics_error</code> and  <code>dynamics_error_jacobian!</code>. If the method wants to provide the functionality of an  explicit integrator (as described in the previous section), it should store internally  a <a href="@ref"><code>ImplicitNewtonCache</code></a>, which must be returned using the getter function  <code>getnewtoncache</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/22020a22da96f83b59ecc43f025ce3de01bf65ed/src/discretized_dynamics.jl#L53-L98">source</a></section></article><h2 id="Implemented-Integrators-1"><a class="docs-heading-anchor" href="#Implemented-Integrators-1">Implemented Integrators</a><a class="docs-heading-anchor-permalink" href="#Implemented-Integrators-1" title="Permalink"></a></h2><h3 id="Explicit-1"><a class="docs-heading-anchor" href="#Explicit-1">Explicit</a><a class="docs-heading-anchor-permalink" href="#Explicit-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.Euler" href="#RobotDynamics.Euler"><code>RobotDynamics.Euler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Euler</code></pre><p>Explicit Euler integration:</p><div>\[x_{k+1} = x_k + h f(x_k, u_k)\]</div><p>where <span>$h$</span> is the time step.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>In general, explicit Euler integration <strong>SHOULD NOT BE USED!</strong> It is the worst possible  integration method since it is very inaccurate and can easily go unstable.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/22020a22da96f83b59ecc43f025ce3de01bf65ed/src/integration.jl#L55-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.RK3" href="#RobotDynamics.RK3"><code>RobotDynamics.RK3</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RK3</code></pre><p>A third-order explicit Runge-Kutta method:</p><div>\[\begin{aligned}
&amp;k_1 = f(x_k, u_k, t) h \\
&amp;k_2 = f(x_k + \frac{1}{2} k_1, u_k, t, + \frac{1}{2} h) h \\
&amp;k_3 = f(x_k - k_1 + 2 k_2, u_k, t, + h) h \\
&amp;x_{k+1} = x_k + \frac{1}{6} (k_1 + 4 k_2 + k_3) 
\end{aligned}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/22020a22da96f83b59ecc43f025ce3de01bf65ed/src/integration.jl#L95-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.RK4" href="#RobotDynamics.RK4"><code>RobotDynamics.RK4</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RK4</code></pre><p>The classic fourth-order explicit Runge-Kutta method.</p><div>\[\begin{aligned}
&amp; k_1 = f(x_k, u_k, t) h \\
&amp; k_2 = f(x_k + \frac{1}{2} k_1, u_k, t + \frac{1}{2} h) h \\
&amp; k_3 = f(x_k + \frac{1}{2} k_2, u_k, t + \frac{1}{2} h) h \\
&amp; k_4 = f(x_k +  k_3, u_k, t + h) h \\
&amp; x_{k+1} = x_k + \frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)
\end{aligned}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/22020a22da96f83b59ecc43f025ce3de01bf65ed/src/integration.jl#L243-L257">source</a></section></article><h3 id="Implicit-1"><a class="docs-heading-anchor" href="#Implicit-1">Implicit</a><a class="docs-heading-anchor-permalink" href="#Implicit-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.ImplicitMidpoint" href="#RobotDynamics.ImplicitMidpoint"><code>RobotDynamics.ImplicitMidpoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ImplicitMidpoint</code></pre><p>A symplectic method with second-order accuracy. A great option for those wanting  good performance with few calls to the dynamics.</p><p><code>math x_1 + h f(\frac{1}{2}(x_1 + x_2), u_1, t + \frac{1}{2} h) - x_2 = 0</code>`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/22020a22da96f83b59ecc43f025ce3de01bf65ed/src/integration.jl#L593-L602">source</a></section></article><h3 id="Interal-API-1"><a class="docs-heading-anchor" href="#Interal-API-1">Interal API</a><a class="docs-heading-anchor-permalink" href="#Interal-API-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RobotDynamics.ADVector" href="#RobotDynamics.ADVector"><code>RobotDynamics.ADVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ADVector{T}</code></pre><p>A cache of vectors for making it easier to ForwardDiff. A vector of the desired type      is extracted by indexing:</p><pre><code class="language-none">vec = adv[eltype(x)]</code></pre><p>Since ForwardDiff Duals are parameterized on the chunk size, this type will store any  number of vectors for different chunk sizes. A new vector of duals will be automatically created (once) if it doesn&#39;t exist yet.</p><p>For best performance (by avoiding type-instability), annotate the indexing operation:</p><pre><code class="language-none">vec = adv[T]::Vector{T}</code></pre><p>While the annotation could have been included in the indexing operation itself, some  benchmark results found it significantly faster to apply the annotation at the call site.</p><p><strong>Constructor</strong></p><pre><code class="language-none">ADVector{T}(n)</code></pre><p>where <code>n</code> is the size of the vectors, and <code>T</code> is the numeric type (typically <code>Float64</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/RobotDynamics.jl/blob/22020a22da96f83b59ecc43f025ce3de01bf65ed/src/integration.jl#L1-L25">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="continuous.html">« Continuous Dynamics</a><a class="docs-footer-nextpage" href="rotationstate.html">The Rotation State »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 29 March 2022 14:13">Tuesday 29 March 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
